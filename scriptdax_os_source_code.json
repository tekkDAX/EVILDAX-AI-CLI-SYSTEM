
{
  "projectName": "ScriptDaX OS",
  "extractionTimestamp": "2024-08-01T10:00:00.000Z",
  "directive": "Protokoll-Anforderung für Quellcode-Extraktion",
  "sourceFiles": [
    {
      "path": "index.tsx",
      "content": ""
    },
    {
      "path": "metadata.json",
      "content": "\n{\n  \"name\": \"ScriptDaX OS\",\n  \"description\": \"An interactive, quest-driven simulation system for managing scripts and addons.\",\n  \"requestFramePermissions\": [],\n  \"prompt\": \"\"\n}"
    },
    {
      "path": "changelog.md",
      "content": "\n# ScriptDaX OS - Changelog\n\nAlle wichtigen Änderungen an diesem Projekt werden in dieser Datei dokumentiert.\n\n## [5.1.0] - The Research & Development Lab\n### Hinzugefügt\n- **Neues Kern-Feature \"Forschungs & Entwicklungs-Labor\":**\n  - Ein neuer Spielbereich ist über das Hauptmenü zugänglich.\n  - Spieler können nun Credits und XP investieren, um über einen visuellen **Technologiebaum** permanente Boni freizuschalten.\n  - Technologien haben Abhängigkeiten, Kosten und schalten systemweite Boni frei (z.B. erhöhte XP-Belohnungen, reduzierte KI-Kosten).\n- **Neue Architektur:**\n  - `ResearchLab.js` und `TechNode.js` Komponenten zur Darstellung des Technologiebaums.\n  - `tech_tree.js` als zentrale Konfigurationsdatei für alle verfügbaren Technologien.\n  - SVG-Linien zur dynamischen Visualisierung von Technologie-Abhängigkeiten.\n\n### Geändert\n- **State Management:**\n  - Das Spielerprofil wurde um `researchedTechs` erweitert.\n  - Der `reducer` wurde um die `RESEARCH_TECHNOLOGY`-Aktion erweitert, um Technologien freizuschalten und Kosten zu verwalten.\n- **System-Integration:** Bestehende Dienste wie der `aiCostBenefitService` und der `resolveQuestReducer` berücksichtigen nun die Boni aus erforschten Technologien.\n- **Projektbereinigung:** Zahlreiche veraltete und temporäre Dateien (`index.tsx`, `gitignore.txt`, `inhalt.txt`, etc.) wurden entfernt, um das Projekt auf einen sauberen Stand zu bringen.\n\n## [5.0.1] - Go-Live & Security Hardening\n### Hinzugefügt\n- **Kritische Sicherheitsarchitektur (API-Proxy):**\n  - Eine serverseitige \"Proxy\"-Funktion wurde in `functions/gemini-proxy.js` implementiert, um den API-Schlüssel sicher auf dem Server zu halten.\n  - Eine `netlify.toml`-Datei wurde hinzugefügt, um den automatisierten Build- und Deployment-Prozess (inkl. Proxy) auf Netlify zu steuern.\n  - Eine `public/index.html` wurde als Vorlage für den Produktions-Build hinzugefügt.\n\n### Geändert\n- **Code-Struktur & Refactoring:**\n  - Alle KI-Dienste (`aiService`, `aiApplicationStrategistService` etc.) wurden überarbeitet, um Anfragen über den sicheren Proxy zu leiten.\n  - Das `@google/genai` SDK und jegliche Prompt-Logik wurden vollständig vom Client entfernt und sind nun ausschließlich serverseitig.\n- **Dokumentation:** README und DEV_BRIEFING wurden um einen entscheidenden Abschnitt zum sicheren Deployment-Prozess und zur Handhabung von Umgebungsvariablen erweitert.\n\n### Behoben\n- **KRITISCHE SICHERHEITSLÜCKE:** Der Gemini API-Schlüssel wird nicht mehr im Frontend-Code referenziert oder geladen, was ein Veröffentlichen des Schlüssels verhindert.\n\n---\n*Ältere Einträge wurden aus Übersichtlichkeitsgründen archiviert.*"
    },
    {
      "path": "src/config/prompts.js",
      "content": ""
    },
    {
      "path": "src/services/aiService.js",
      "content": "\nimport { fallbackQuests } from '../config/fallbackQuests.js';\nimport { callProxy } from './proxyHelper.js';\n\nexport const aiService = {\n    isConfigured: true, // The client assumes the proxy is configured. Errors are handled by the call.\n\n    async generateQuests(characterProfile, settings, mindsetState, completedQuestHistory) {\n        if (settings?.useLocalFallback) {\n            console.log('%c[SPARMODUS AKTIV]', 'color: #ffc107; font-weight: bold;', 'Liefere lokale Fallback-Quests statt API-Aufruf.');\n            await new Promise(resolve => setTimeout(resolve, 750));\n            return {\n                quests: fallbackQuests,\n                usage: { totalTokens: 0, source: 'local' },\n            };\n        }\n\n        const data = await callProxy('generateQuests', { characterProfile, mindsetState, completedQuestHistory });\n        return data;\n    },\n\n    async getAIBetaProgramOpinion() {\n        const data = await callProxy('getAIBetaProgramOpinion', {});\n        // The proxy now returns a simple string for this service\n        return data.text;\n    }\n};"
    },
    {
      "path": "src/store/useAppStore.js",
      "content": "\nimport { useReducer, useEffect, useMemo, useCallback, useRef } from 'preact/hooks';\nimport JSZip from 'jszip';\nimport { aiService } from '../services/aiService.js';\nimport { audioService } from '../services/audioService.js';\nimport { aiAnalystService } from '../services/aiAnalystService.js';\nimport { virtualTeamService } from '../services/virtualTeamService.js';\nimport { aiApplicationStrategistService } from '../services/aiApplicationStrategistService.js';\nimport { aiMentalCoachService } from '../services/aiMentalCoachService.js';\nimport { aiProjectManagerService } from '../services/aiProjectManagerService.js';\nimport { aiSecurityAuditorService } from '../services/aiSecurityAuditorService.js';\nimport { aiCostBenefitService } from '../services/aiCostBenefitService.js';\nimport { aiCommunityManagerService } from '../services/aiCommunityManagerService.js';\nimport { aiBiographerService } from '../services/aiBiographerService.js';\nimport { appReducer, initialState } from './reducer.js';\nimport { downloadFile } from './helpers.js';\nimport { persistenceService } from '../services/persistenceService.js';\n\nexport const useAppStore = () => {\n    // --- STATE MANAGEMENT ---\n    const [state, dispatch] = useReducer(appReducer, initialState);\n    const stateRef = useRef(state);\n    useEffect(() => {\n        stateRef.current = state;\n    }, [state]);\n\n    // --- PERSISTENCE ---\n    // A single, consolidated effect to save the entire relevant state to localStorage.\n    useEffect(() => {\n        persistenceService.saveFullState(state);\n    }, [state.rawProfiles, state.activeProfileId, state.settings, state.betaLicenseKeys, state.reports, state.fixLogs]);\n\n\n    // --- SELECTORS ---\n    const activeSectors = useMemo(() => \n        (state.quests || [])\n            .map(q => q?.sector?.toLowerCase())\n            .filter(Boolean), \n        [state.quests]\n    );\n    const completedSectors = useMemo(() => \n        (state.completedQuests || [])\n            .map(q => q?.sector?.toLowerCase())\n            .filter(Boolean), \n        [state.completedQuests]\n    );\n    const newReportsCount = useMemo(() => state.reports.filter(r => !r.isArchived).length, [state.reports]);\n    const allDiscoveredNPCs = useMemo(() => {\n        const allNpcs = state.profiles.flatMap(p => p.discoveredNPCs || []);\n        const uniqueNpcs = new Map();\n        for (const npc of allNpcs) {\n            if (npc && npc.name) {\n                uniqueNpcs.set(npc.name, npc);\n            }\n        }\n        return Array.from(uniqueNpcs.values());\n    }, [state.profiles]);\n    const xpForNextLevel = useMemo(() => Math.floor(100 * Math.pow(state.characterStats.level, 1.5)), [state.characterStats.level]);\n    const unverifiedFixLogsCount = useMemo(() => state.fixLogs.filter(log => !log.qaStatus || log.qaStatus.grade === 0).length, [state.fixLogs]);\n\n\n    // --- APP INITIALIZATION ---\n    useEffect(() => {\n        const initializeApp = async () => {\n            dispatch({ type: 'SET_LOADING_MESSAGE', payload: 'Initialisiere Audiosystem...' });\n            \n            const onAudioProgress = (loaded, total) => {\n                const progress = Math.round((loaded / total) * 100);\n                dispatch({ type: 'SET_LOADING_PROGRESS', payload: { progress, message: `Lade Audiodaten... [${loaded}/${total}]` } });\n            };\n\n            await audioService.init(onAudioProgress);\n            dispatch({ type: 'SET_LOADING_MESSAGE', payload: 'Initialisierung abgeschlossen.' });\n\n            setTimeout(() => {\n                dispatch({ type: 'APP_INITIALIZED' });\n            }, 500);\n        };\n        initializeApp();\n    }, []);\n\n    // --- AUDIO HOOKS ---\n    useEffect(() => {\n        audioService.setMusicVolume(state.settings.musicVolume);\n        audioService.setSfxVolume(state.settings.sfxVolume);\n    }, [state.settings]);\n\n    useEffect(() => {\n        if (state.isMusicActive) {\n            audioService.playMusic();\n        } else {\n            audioService.stopMusic();\n        }\n    }, [state.isMusicActive]);\n    \n    // Stable function to get the latest state without causing re-renders\n    const getState = useCallback(() => stateRef.current, []);\n\n    // --- AUTONOMOUS AI ANALYSIS ---\n    const runAutonomousAnalysis = (actionType = '') => {\n        const currentState = getState();\n\n        // Oracle-7 (Mental Coach)\n        if (currentState.lastCoachInterventionTimestamp && Date.now() - currentState.lastCoachInterventionTimestamp < 30000) { // 30 sec cooldown\n            // do nothing\n        } else {\n            const coachMessage = aiMentalCoachService.analyzeAction(currentState);\n            if (coachMessage) {\n                dispatch({ type: 'TRIGGER_MENTAL_COACH_INTERVENTION', payload: coachMessage });\n            }\n        }\n        \n        // Helios-PM (Project Manager)\n        if (currentState.projectActionCounter >= 5) { // Check every 5 actions\n            const pmMessage = aiProjectManagerService.analyzeProjectState(currentState);\n            if (pmMessage) {\n                dispatch({ type: 'TRIGGER_PROJECT_MANAGER_INTERVENTION', payload: pmMessage });\n            }\n        }\n        \n        // Cerberus-QA (Security Auditor)\n        const auditTriggerActions = ['RESOLVE_QUEST', 'UPDATE_FIX_LOG_QA', 'SET_LINUX_BUILD_SUCCESS'];\n        if (auditTriggerActions.includes(actionType)) {\n             const auditResult = aiSecurityAuditorService.runAudit(currentState);\n             if (auditResult) {\n                 dispatch({ type: 'INJECT_BUG_REPORT', payload: auditResult.bugReport });\n                 dispatch({ type: 'TRIGGER_TEAM_ANALYSIS', payload: { message: auditResult.message } });\n                 showNotification(\"Sicherheits-Audit hat einen neuen, kritischen Fehler aufgedeckt!\", \"error\");\n             }\n        }\n    };\n\n    // --- ACTION CREATORS ---\n    const actions = useMemo(() => {\n        \n        const sanitizeFilename = (name) => (name || '').replace(/[\\/\\\\?%*:|\"<>]/g, '_');\n\n        const showNotification = (message, type = 'info', duration = 4000) => {\n            const id = self.crypto.randomUUID();\n            const iconMap = { success: 'reputation', error: 'bug', info: 'dialogue' };\n            dispatch({ type: 'SHOW_NOTIFICATION', payload: { id, message, type, icon: iconMap[type] } });\n            setTimeout(() => {\n                dispatch({ type: 'SET_NOTIFICATION_EXITING', payload: id });\n            }, duration);\n        };\n        \n        const triggerTeamAnalysis = (payload) => {\n             const analysisResult = virtualTeamService.analyzeEvent(payload.eventType, payload.eventData, getState());\n             if (analysisResult) {\n                 dispatch({ type: 'TRIGGER_TEAM_ANALYSIS', payload: analysisResult });\n             }\n        };\n        \n        const timestampedDispatch = (action) => {\n            const fullAction = { ...action, payload: { ...action.payload, timestamp: Date.now() }};\n            dispatch(fullAction);\n            runAutonomousAnalysis(action.type);\n        }\n\n        const generateNewQuests = async (profileToUse) => {\n            if (!profileToUse) return;\n            dispatch({ type: 'GENERATE_QUESTS_START' });\n            try {\n                const { settings, characterStats, activeProfile } = getState();\n                const completedQuestHistory = profileToUse.completedQuestHistory || [];\n                const { quests, usage } = await aiService.generateQuests(profileToUse, settings, characterStats.mindsetState, completedQuestHistory);\n                \n                const analysis = aiCostBenefitService.analyzeQuestGeneration(usage, quests, activeProfile?.researchedTechs || []);\n                \n                timestampedDispatch({ type: 'GENERATE_QUESTS_SUCCESS', payload: { quests, profileId: profileToUse.id, analysis }});\n                \n                let successMessage = `<strong>${quests.length} neue Quests</strong> empfangen.`;\n                if (usage?.source !== 'local') {\n                    successMessage += ` <em>(ROI-Rating: ${analysis.rating})</em>`;\n                }\n                showNotification(successMessage, 'success');\n\n            } catch (e) {\n                console.error(e);\n                const msg = e.message || 'Unbekannter Fehler bei Quest-Generierung.';\n                dispatch({ type: 'API_ERROR', payload: msg });\n                showNotification(`Quest-Generierung fehlgeschlagen: ${msg}`, 'error');\n            }\n        };\n        \n        const completeProfileCreation = async (creationData) => {\n            const { name } = creationData;\n            const newProfileId = self.crypto.randomUUID();\n            dispatch({ type: 'CREATE_PROFILE', payload: { ...creationData, id: newProfileId } });\n\n            const displayName = name.replace('.beta666', '').replace('.dev666', '');\n            const message = name.endsWith('.beta666')\n                ? `Beta-Profil für <strong>${displayName}</strong> erstellt.`\n                : `Operator-Profil für <strong>${displayName}</strong> initialisiert.`;\n            showNotification(message, 'success');\n\n            const newProfile = { ...creationData, id: newProfileId, quests: [], completedQuests: [], inventory: [], failedQuests: [] };\n            await generateNewQuests(newProfile);\n        };\n        \n        const updateFixLogQaStatus = (logId, grade) => {\n            timestampedDispatch({ type: 'UPDATE_FIX_LOG_QA', payload: { logId, grade } });\n            if (grade >= 1 && grade <= 3) {\n                 showNotification(`Fix verifiziert. <strong>+25 XP</strong>`, 'success');\n            }\n        };\n\n        const submitReport = (reportData) => {\n            audioService.playSound('success');\n            timestampedDispatch({ type: 'SUBMIT_REPORT', payload: reportData });\n            showNotification(`Report (<strong>${reportData.category}</strong>) gespeichert. <strong>+10 XP</strong>`, 'success');\n        };\n\n        return {\n            // --- UI & State Actions ---\n            setGameState: (payload) => dispatch({ type: 'SET_GAME_STATE', payload }),\n            setSettings: (payload) => dispatch({ type: 'SET_SETTINGS', payload }),\n            setTheme: (payload) => dispatch({ type: 'SET_THEME', payload }),\n            showNotification,\n            hideNotification: (payload) => dispatch({ type: 'HIDE_NOTIFICATION', payload }),\n            proceedFromLanding: () => {\n                const { activeProfileId } = getState();\n                const nextState = activeProfileId ? 'preload' : 'main-menu';\n                audioService.playClickSound();\n                dispatch({ type: 'SET_MUSIC_ACTIVE', payload: true });\n                dispatch({ type: 'SET_GAME_STATE', payload: nextState });\n            },\n            goToMainMenu: () => {\n                audioService.playClickSound();\n                dispatch({ type: 'SET_MUSIC_ACTIVE', payload: true });\n                dispatch({ type: 'SET_GAME_STATE', payload: 'main-menu' });\n            },\n\n            // --- Core Gameplay Loop ---\n            generateNewQuests,\n            resolveQuest: (questId, chosenOutcome) => {\n                const { quests, characterStats: oldCharacterStats } = getState();\n                const quest = quests.find(q => q.id === questId);\n                if (!quest) return;\n                \n                audioService.playSound(chosenOutcome.status === 'failure' ? 'fail' : 'success');\n                timestampedDispatch({ type: 'RESOLVE_QUEST', payload: { quest, chosenOutcome }});\n\n                const newState = getState();\n                triggerTeamAnalysis({\n                    eventType: chosenOutcome.status === 'failure' ? 'QUEST_FAILURE' : 'QUEST_SUCCESS',\n                    eventData: { newStats: newState.characterStats, oldStats: oldCharacterStats }\n                });\n\n                if (chosenOutcome.rewards.item) {\n                    showNotification(`Item erhalten: <strong>${chosenOutcome.rewards.item.name}</strong>`, 'info');\n                }\n                if (chosenOutcome.status === 'success') {\n                     showNotification(`Quest \"${quest.title}\" abgeschlossen.`, 'success');\n                } else {\n                     showNotification(`Quest \"${quest.title}\" fehlgeschlagen.`, 'error');\n                }\n            },\n            researchTechnology: (techId) => {\n                audioService.playSound('success');\n                timestampedDispatch({ type: 'RESEARCH_TECHNOLOGY', payload: { techId } });\n            },\n\n            // --- Profile & Data Management ---\n            continueLastSession: () => dispatch({ type: 'LOAD_LAST_PROFILE' }),\n            startNewGame: () => {\n                audioService.playClickSound();\n                dispatch({ type: 'SET_GAME_STATE', payload: 'character-creator'})\n            },\n            loadProfile: (profileId) => {\n                audioService.playClickSound();\n                dispatch({ type: 'LOAD_PROFILE', payload: profileId });\n                showNotification('Profil geladen.', 'info');\n            },\n            deleteProfile: (profileId) => {\n                audioService.playSound('fail');\n                dispatch({ type: 'DELETE_PROFILE', payload: profileId });\n                showNotification('Profil gelöscht.', 'error');\n            },\n            deleteActiveProfile: () => {\n                audioService.playSound('fail');\n                dispatch({ type: 'DELETE_ACTIVE_PROFILE' });\n                showNotification('Aktives Profil gelöscht.', 'error');\n            },\n            confirmCharacterCreation: (creationData) => {\n                audioService.playClickSound();\n                const isBeta = creationData.name.endsWith('.beta666');\n                if (isBeta) {\n                    dispatch({ type: 'START_BETA_CREATION', payload: creationData });\n                } else {\n                    completeProfileCreation(creationData);\n                }\n            },\n            importData: (event) => {\n                const file = event.target.files[0];\n                if (!file) return;\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        let profilesToImport = [];\n                        if (file.name.endsWith('.zip')) {\n                            const zip = await JSZip.loadAsync(e.target.result);\n                            for (const filename in zip.files) {\n                                if (filename.endsWith('.json')) {\n                                    profilesToImport.push(JSON.parse(await zip.files[filename].async('string')));\n                                }\n                            }\n                        } else {\n                            profilesToImport.push(JSON.parse(e.target.result));\n                        }\n                        dispatch({ type: 'IMPORT_PROFILES', payload: profilesToImport });\n                        showNotification('Daten erfolgreich importiert.', 'success');\n                    } catch (err) {\n                        console.error(\"Import failed:\", err);\n                        showNotification('Daten-Import fehlgeschlagen. Ungültige Datei.', 'error');\n                    }\n                };\n                reader[file.name.endsWith('.zip') ? 'readAsArrayBuffer' : 'readAsText'](file);\n                event.target.value = '';\n            },\n            exportProfileZip: () => {\n                const { activeProfile, rawProfiles } = getState();\n                if (!activeProfile) return;\n                const p = rawProfiles.find(p => p.id === activeProfile.id);\n                if (!p) return;\n                const zip = new JSZip();\n                const safeInnerName = sanitizeFilename(p.characterStats.name);\n                zip.file(`${safeInnerName}.json`, JSON.stringify(p, null, 2));\n                const safeOuterName = sanitizeFilename(activeProfile.characterStats.displayName);\n                zip.generateAsync({ type: \"blob\" }).then(content => downloadFile(content, `scriptdax_profile_${safeOuterName}.zip`, 'application/zip'));\n                showNotification('Aktives Profil exportiert.', 'info');\n            },\n            exportAllProfilesZip: () => {\n                const { rawProfiles } = getState();\n                if (rawProfiles.length === 0) return;\n                const zip = new JSZip();\n                rawProfiles.forEach(p => {\n                    const safeInnerName = sanitizeFilename(p.characterStats.name);\n                    zip.file(`${safeInnerName}.json`, JSON.stringify(p, null, 2))\n                });\n                zip.generateAsync({ type: \"blob\" }).then(content => downloadFile(content, 'scriptdax_all_profiles.zip', 'application/zip'));\n                showNotification('Alle Profile exportiert.', 'info');\n            },\n            createBackup: () => {\n                const currentState = getState();\n                const stateToBackup = {\n                    version: \"1.0\",\n                    timestamp: new Date().toISOString(),\n                    rawProfiles: currentState.rawProfiles,\n                    settings: currentState.settings,\n                    betaLicenseKeys: currentState.betaLicenseKeys,\n                    reports: currentState.reports,\n                    fixLogs: currentState.fixLogs,\n                };\n                const jsonString = JSON.stringify(stateToBackup, null, 2);\n                downloadFile(jsonString, `scriptdax_os_backup_${new Date().toISOString().split('T')[0]}.json`, 'application/json');\n                showNotification('Komplettes System-Backup erstellt.', 'success');\n            },\n            restoreFromBackup: (event) => {\n                const file = event.target.files[0];\n                if (!file) return;\n                const reader = new FileReader();\n                reader.onload = (e) => {\n                    try {\n                        const backup = JSON.parse(e.target.result);\n                        if (!backup.rawProfiles || !backup.settings) {\n                            throw new Error(\"Invalides Backup-Format.\");\n                        }\n                        dispatch({ type: 'RESTORE_STATE', payload: backup });\n                        showNotification('System wird aus Backup wiederhergestellt...', 'info', 2500);\n                        setTimeout(() => window.location.reload(), 1500);\n                    } catch (err) {\n                        console.error(\"Restore failed:\", err);\n                        showNotification(`Wiederherstellung fehlgeschlagen: ${err.message}`, 'error');\n                    }\n                };\n                reader.readAsText(file);\n                event.target.value = '';\n            },\n\n            // --- Beta Program & Reporting ---\n            validateAndCompleteBetaCreation: (key) => {\n                const { betaLicenseKeys, pendingBetaCreation } = getState();\n                if (!key || !betaLicenseKeys.includes(key)) {\n                    dispatch({ type: 'SET_BETA_KEY_ERROR', payload: 'Ungültiger oder bereits verwendeter Schlüssel.'});\n                    return;\n                }\n                audioService.playSound('success');\n                dispatch({ type: 'CONSUME_BETA_KEY', payload: key });\n                completeProfileCreation(pendingBetaCreation);\n            },\n            cancelBetaCreation: () => { audioService.playClickSound(); dispatch({ type: 'CANCEL_BETA_CREATION' }); },\n            generateBetaLicenseKey: () => {\n                const { activeProfile } = getState();\n                if (activeProfile?.isDeveloper) {\n                    const newKey = `BETA-${self.crypto.randomUUID().slice(0, 8).toUpperCase()}`;\n                    dispatch({ type: 'ADD_BETA_KEY', payload: newKey });\n                    showNotification(`Beta-Schlüssel generiert: <strong>${newKey}</strong>`, 'info');\n                }\n            },\n            openReportModal: () => dispatch({ type: 'SET_MODAL_STATE', payload: { modal: 'report', isOpen: true } }),\n            closeReportModal: () => dispatch({ type: 'SET_MODAL_STATE', payload: { modal: 'report', isOpen: false } }),\n            submitReport,\n            updateFixLogQaStatus,\n            exportReports: () => {\n                const currentState = getState();\n                const failedFixReportIds = new Set(\n                    currentState.fixLogs\n                        .filter(log => log.qaStatus && log.qaStatus.grade >= 4)\n                        .flatMap(log => log.reportIds)\n                );\n\n                if (failedFixReportIds.size > 0) {\n                     dispatch({ type: 'REOPEN_REPORTS', payload: Array.from(failedFixReportIds) });\n                }\n\n                setTimeout(() => {\n                    const updatedReports = getState().reports; \n                    const reportsToExport = updatedReports.filter(r => !r.isArchived);\n\n                    if (reportsToExport.length === 0) {\n                        showNotification(\"Keine neuen Reports zum Exportieren vorhanden.\", 'info');\n                        return;\n                    }\n\n                    const jsonString = JSON.stringify(reportsToExport, null, 2);\n                    downloadFile(jsonString, `scriptdax_reports_${new Date().toISOString().split('T')[0]}.json`, 'application/json');\n\n                    const exportedIds = reportsToExport.map(r => r.id);\n                    dispatch({ type: 'ARCHIVE_REPORTS', payload: { ids: exportedIds, reopen: false } });\n\n                    let message = `${exportedIds.length} neue(r) Report(s) exportiert & archiviert.`;\n                    if(failedFixReportIds.size > 0) {\n                        message += ` Zusätzlich wurden ${failedFixReportIds.size} Report(s) von fehlgeschlagenen Fixes wiedereröffnet.`\n                    }\n                    showNotification(message, 'success');\n                    timestampedDispatch({ type: 'TIMESTAMP_ACTION' });\n                }, 100); \n            },\n            logAiFixAndArchiveReports: () => {\n                 const { reports } = getState();\n                 const reportsToProcess = reports.filter(r => !r.isArchived);\n                 if (reportsToProcess.length === 0) {\n                    showNotification(\"Keine neuen Reports zur Verarbeitung gefunden.\", 'info');\n                    return;\n                 }\n                 const reportIds = reportsToProcess.map(r => r.id);\n                 const fixLog = {\n                    id: self.crypto.randomUUID(),\n                    timestamp: new Date().toISOString(),\n                    aiFixNote: `Simulierter KI-Fix für ${reportIds.length} Report(s). Probleme im Zusammenhang mit [Komponente X] und [Funktion Y] wurden adressiert.`,\n                    reportIds: reportIds,\n                 };\n                 timestampedDispatch({ type: 'LOG_AI_FIX', payload: fixLog });\n                 dispatch({ type: 'ARCHIVE_REPORTS', payload: { ids: reportIds, reopen: false }});\n                 showNotification(`Fix für ${reportIds.length} Report(s) protokolliert und Reports archiviert.`, 'success');\n            },\n            \n            // --- AI & System Actions ---\n            getBetaProgramOpinion: async () => {\n                dispatch({ type: 'GET_BETA_OPINION_START' });\n                try {\n                    const opinion = await aiService.getAIBetaProgramOpinion();\n                    timestampedDispatch({ type: 'GET_BETA_OPINION_SUCCESS', payload: { opinion } });\n                    showNotification('Team-Meinung erfolgreich empfangen.', 'success');\n                    triggerTeamAnalysis({ eventType: 'MARKET_ANALYSIS_COMPLETE', eventData: {} });\n                } catch (e) {\n                    console.error(e);\n                    const msg = e.message || 'Unbekannter Fehler bei der Analyse.';\n                    dispatch({ type: 'GET_BETA_OPINION_ERROR', payload: msg });\n                    showNotification(`Analyse fehlgeschlagen: ${msg}`, 'error');\n                }\n            },\n            getApplicationStrategy: async (program) => {\n                dispatch({ type: 'GET_APP_STRATEGY_START', payload: { programId: program.id } });\n                try {\n                    const currentState = getState();\n                    const strategy = await aiApplicationStrategistService.generateStrategy(program, currentState);\n                    timestampedDispatch({ type: 'GET_APP_STRATEGY_SUCCESS', payload: { programId: program.id, strategy } });\n                    showNotification(`Strategie für \"${program.programName}\" erhalten.`, 'success');\n                } catch (e) {\n                    console.error(e);\n                    const msg = e.message || 'Strategie-Generierung fehlgeschlagen.';\n                    dispatch({ type: 'GET_APP_STRATEGY_ERROR', payload: { programId: program.id, error: msg } });\n                    showNotification(`Fehler: ${msg}`, 'error');\n                }\n            },\n            generateBiography: async () => {\n                dispatch({ type: 'GENERATE_BIOGRAPHY_START' });\n                try {\n                    const response = await fetch('./changelog.md');\n                    if (!response.ok) throw new Error(`Changelog konnte nicht geladen werden: ${response.statusText}`);\n                    const changelogContent = await response.text();\n                    \n                    const currentState = getState();\n                    const biographyText = await aiBiographerService.generateBiography(currentState.activeProfile, changelogContent);\n                    dispatch({ type: 'GENERATE_BIOGRAPHY_SUCCESS', payload: biographyText });\n                    showNotification('Biografie-Entwurf erfolgreich erstellt.', 'success');\n\n                } catch (e) {\n                    console.error(e);\n                    const msg = e.message || 'Fehler bei der Erstellung der Biografie.';\n                    dispatch({ type: 'GENERATE_BIOGRAPHY_ERROR', payload: msg });\n                    showNotification(`Biografie-Erstellung fehlgeschlagen: ${msg}`, 'error');\n                }\n            },\n            startLinuxBuild: () => {\n                dispatch({ type: 'SET_LINUX_BUILD_STATUS', payload: { status: 'building' } });\n                const { activeProfile, reports } = getState();\n                const openReportsCount = reports.filter(r => !r.isArchived).length;\n                const hasOpenCriticalBugs = openReportsCount > 0;\n                \n                setTimeout(() => {\n                    if (activeProfile.characterStats.level < 5 || hasOpenCriticalBugs) {\n                        const reason = activeProfile.characterStats.level < 5 \n                            ? `Operator-Level zu niedrig (benötigt Level 5).` \n                            : `Es gibt ${openReportsCount} offene Bug-Report(s).`;\n                        dispatch({ type: 'SET_LINUX_BUILD_STATUS', payload: { status: 'failure', reason } });\n                        showNotification(`Linux-Build fehlgeschlagen: ${reason}`, 'error');\n                    } else {\n                        timestampedDispatch({ type: 'SET_LINUX_BUILD_SUCCESS' });\n                        showNotification('Linux-Build erfolgreich abgeschlossen! Bonus freigeschaltet.', 'success');\n                    }\n                }, 8000); // 8 second build time\n            },\n            recruitBetaTeam: () => {\n                dispatch({ type: 'RECRUIT_BETA_TEAM_START' });\n                setTimeout(() => {\n                    const team = aiCommunityManagerService.generateTeam();\n                    timestampedDispatch({ type: 'RECRUIT_BETA_TEAM_SUCCESS', payload: { team } });\n                    showNotification(`Beta-Team mit ${team.length} Testern erfolgreich rekrutiert.`, 'success');\n                    triggerTeamAnalysis({ eventType: 'BETA_TEAM_RECRUITED', eventData: {} });\n                }, 5000);\n            },\n\n            // --- Debug & Synthetic Actions ---\n            toggleDebugConsole: () => dispatch({ type: 'TOGGLE_DEBUG_CONSOLE' }),\n            generateAndDisplayAiReport: () => {\n                const currentState = getState();\n                const report = aiAnalystService.generateReport(currentState);\n                dispatch({ type: 'LOG_TO_DEBUG_CONSOLE', payload: report });\n                dispatch({ type: 'SET_DEBUG_CONSOLE_STATE', payload: true });\n                timestampedDispatch({ type: 'TIMESTAMP_ACTION' });\n            },\n            createSyntheticProfile: (preset) => {\n                dispatch({ type: 'CREATE_SYNTHETIC_PROFILE', payload: preset });\n                showNotification(`Synthetisches Profil <strong>${preset.name}</strong> erstellt.`, 'success');\n            },\n            addDebugCredits: () => { audioService.playSound('success'); dispatch({ type: 'ADD_DEBUG_CREDITS' }); },\n            addDebugXp: () => {\n                const { characterStats: oldCharacterStats } = getState();\n                audioService.playSound('levelUp');\n                dispatch({ type: 'ADD_DEBUG_XP' });\n                const { characterStats: newCharacterStats } = getState();\n                if (newCharacterStats.level > oldCharacterStats.level) {\n                     triggerTeamAnalysis({ eventType: 'LEVEL_UP', eventData: { newLevel: newCharacterStats.level, oldLevel: oldCharacterStats.level } });\n                }\n            },\n            resetQuests: () => { audioService.playSound('fail'); dispatch({ type: 'RESET_QUESTS' }); },\n        };\n    }, [dispatch, getState]); \n\n    return { ...state, actions, isApiConfigured: aiService.isConfigured, activeSectors, completedSectors, newReportsCount, allDiscoveredNPCs, xpForNextLevel, unverifiedFixLogsCount };\n};"
    },
    {
      "path": "src/components/App.js",
      "content": "\n\n\n\nimport { h, Fragment } from 'preact';\nimport { useEffect } from 'preact/hooks';\nimport { useStore } from '../store/AppContext.js';\nimport { ControlPanel } from './ControlPanel.js';\nimport { GalaxyMap } from './GalaxyMap.js';\nimport { QuestTerminal } from './QuestTerminal.js';\nimport { LoadingSpinner } from './LoadingSpinner.js';\nimport { MainMenu } from './MainMenu.js';\nimport { Settings } from './Settings.js';\nimport { Credits } from './Credits.js';\nimport { CommsFeed } from './CommsFeed.js';\nimport { CharacterCreator } from './CharacterCreator.js';\nimport { ProfileSelector } from './ProfileSelector.js';\nimport { Codex } from './Codex.js';\nimport { Version } from './Version.js';\nimport { BetaKeyPrompt } from './BetaKeyPrompt.js';\nimport { PreloadScreen } from './PreloadScreen.js';\nimport { SystemCheck } from './SystemCheck.js';\nimport { DebugPanel } from './DebugPanel.js';\nimport { ReportModal } from './ReportModal.js';\nimport { ReportViewer } from './ReportViewer.js';\nimport { LoadingScreen } from './LoadingScreen.js';\nimport { Notifications } from './Notifications.js';\nimport { FixVerificationView } from './FixVerificationView.js';\nimport { MarketAnalysis } from './MarketAnalysis.js';\nimport { LinuxDistribution } from './LinuxDistribution.js';\nimport { BetaManagement } from './BetaManagement.js';\nimport { Dashboard } from './Dashboard.js';\nimport { ProjectChronicle } from './ProjectChronicle.js';\nimport { LandingPage } from './LandingPage.js';\nimport { ResearchLab } from './ResearchLab.js';\n\n\n// The main App component acts as a router, rendering views based on gameState\nexport const App = () => {\n    const { gameState, activeProfile, isReportModalOpen } = useStore();\n\n    useEffect(() => {\n        // Apply the active theme class to the body\n        const theme = activeProfile?.activeTheme || 'default';\n        document.body.className = `theme-${theme}`;\n    }, [activeProfile?.activeTheme]);\n\n    const renderView = () => {\n        switch (gameState) {\n            case 'loading':\n                return h(LoadingScreen);\n            case 'preload':\n                return h(PreloadScreen);\n            case 'landing-page':\n                return h(LandingPage);\n            case 'game':\n                return h(Dashboard); // The Dashboard is the new main game view\n            case 'character-creator':\n            case 'beta-key-entry': // Keep CharacterCreator in background for context\n                return h(CharacterCreator);\n            case 'settings':\n                return h(Settings);\n            case 'credits':\n                return h(Credits);\n            case 'profile-select':\n                return h(ProfileSelector);\n            case 'codex':\n                return h(Codex);\n            case 'system-check':\n                return h(SystemCheck);\n            case 'market-analysis':\n                 return h(MarketAnalysis);\n            case 'linux-initiative':\n                 return h(LinuxDistribution);\n            case 'beta-management':\n                 return h(BetaManagement);\n            case 'project-chronicle':\n                 return h(ProjectChronicle);\n            case 'report-viewer':\n                 return h(ReportViewer);\n            case 'fix-verification':\n                 return h(FixVerificationView);\n            case 'research-lab':\n                 return h(ResearchLab);\n            case 'main-menu':\n            default:\n                return h(MainMenu);\n        }\n    };\n    \n    const showDebugPanel = activeProfile && (activeProfile.isDeveloper || activeProfile.isBetaTester);\n\n    return h(Fragment, null,\n        h(Version),\n        h(Notifications),\n        renderView(),\n        gameState === 'beta-key-entry' && h(BetaKeyPrompt),\n        showDebugPanel && h(DebugPanel),\n        isReportModalOpen && h(ReportModal)\n    );\n};"
    },
    {
      "path": "src/components/ControlPanel.js",
      "content": "\nimport { h } from 'preact';\nimport { CharacterStatus } from './CharacterStatus.js';\nimport { useStore } from '../store/AppContext.js';\nimport { Icon } from './Icon.js';\nimport { Inventory } from './Inventory.js';\nimport { QUEST_LOG_CAPACITY } from '../store/initialState.js';\nimport { CostBenefitAnalysis } from './CostBenefitAnalysis.js';\n\nconst LearningGoalDisplay = () => {\n    const { learningGoal } = useStore();\n    \n    if (!learningGoal || !learningGoal.keyword) {\n        return null;\n    }\n\n    return h('div', { className: 'learning-goal-display' },\n        h('h3', { className: 'learning-goal-title' }, 'Aktives Lernziel'),\n        h('p', { className: 'learning-goal-keyword' }, learningGoal.keyword),\n        h('p', { className: 'learning-goal-description' }, learningGoal.description)\n    );\n};\n\n\nexport const ControlPanel = () => {\n    const { isLoading, isApiConfigured, error, activeProfile, quests, actions, costBenefitAnalysis } = useStore();\n    \n    const handleGenerate = () => {\n        actions.generateNewQuests(activeProfile);\n    };\n\n    const isQuestLogFull = quests.length >= QUEST_LOG_CAPACITY;\n    const generateButtonDisabled = isLoading || !isApiConfigured || !activeProfile || isQuestLogFull;\n    \n    let buttonText = 'Neue Quests generieren';\n    if (isLoading) {\n        buttonText = 'Generiere...';\n    } else if (isQuestLogFull) {\n        buttonText = 'Quest-Logbuch voll';\n    }\n\n    return h('aside', { className: 'control-panel' },\n        h('h1', { className: 'panel-title' }, 'Kontrollzentrum'),\n        h(CharacterStatus),\n        h(LearningGoalDisplay),\n        h(Inventory),\n        costBenefitAnalysis && h(CostBenefitAnalysis, { analysis: costBenefitAnalysis }),\n        h('div', { className: 'controls' },\n            h('button', {\n                className: 'button',\n                onClick: handleGenerate,\n                disabled: generateButtonDisabled,\n                title: isQuestLogFull ? `Maximale Anzahl von ${QUEST_LOG_CAPACITY} Quests erreicht.` : ''\n            }, buttonText),\n            h('button', {\n                className: 'button secondary',\n                onClick: actions.goToMainMenu,\n            }, 'Hauptmenü'),\n            !isApiConfigured && !isLoading && h('p', { style: { color: 'var(--accent-negative)', marginTop: '1rem', fontSize: '0.9rem', 'background': 'rgba(244, 67, 54, 0.1)', 'padding': '0.5rem', 'border-left': '3px solid var(--accent-negative)', 'border-radius': '4px' } }, 'API nicht konfiguriert. Die Quest-Generierung wird fehlschlagen. Stellen Sie sicher, dass die Umgebungsvariable API_KEY gesetzt ist.'),\n            error && h('p', { style: { color: 'var(--accent-negative)', marginTop: '1rem' } }, `Fehler: ${error}`)\n        )\n    );\n};"
    },
    {
      "path": "src/components/CharacterStatus.js",
      "content": "\nimport { h } from 'preact';\nimport { useStore } from '../store/AppContext.js';\nimport { useState, useEffect } from 'preact/hooks';\n\nconst ReputationMeter = ({ faction, value }) => {\n    return h('div', { className: 'status-item' },\n        h('div', { className: 'status-item-header' },\n            h('span', { className: 'status-item-label' }, faction),\n            h('span', { className: 'status-item-value' }, `${value}%`)\n        ),\n        h('div', { className: 'reputation-bar' },\n            h('div', { className: 'reputation-bar-inner', style: { width: `${value}%` } })\n        )\n    );\n};\n\nconst XPMeter = () => {\n    const { characterStats, xpForNextLevel } = useStore();\n    const { xp } = characterStats;\n    const progress = xpForNextLevel > 0 ? (xp / xpForNextLevel) * 100 : 0;\n    const [isGaining, setIsGaining] = useState(false);\n\n    // Effect to trigger flash animation on XP gain\n    useEffect(() => {\n        // Don't flash on initial load\n        if (xp > 0) {\n            setIsGaining(true);\n            const timer = setTimeout(() => setIsGaining(false), 500); // Duration of the animation\n            return () => clearTimeout(timer);\n        }\n    }, [xp]);\n\n    return h('div', { className: 'status-item' },\n        h('div', { className: 'status-item-header' },\n            h('span', { className: 'status-item-label' }, 'XP'),\n            h('span', { className: 'xp-display' }, `${xp.toLocaleString()} / ${xpForNextLevel.toLocaleString()}`)\n        ),\n        h('div', { className: 'xp-bar' },\n            h('div', { className: `xp-bar-inner ${isGaining ? 'is-gaining' : ''}`, style: { width: `${progress}%` } })\n        )\n    );\n}\n\nexport const CharacterStatus = () => {\n    const { characterStats } = useStore();\n\n    const getMoralityClass = (value) => {\n        if (value > 60) return 'positive';\n        if (value < 40) return 'negative';\n        return '';\n    };\n\n    return h('div', { className: 'character-status-panel' },\n        h('h2', { className: 'character-name' }, characterStats.displayName),\n        h('div', { className: 'status-item' },\n             h('div', { className: 'status-item-header' },\n                h('span', { className: 'status-item-label' }, 'Level'),\n                h('span', { className: 'level-display' }, characterStats.level)\n            )\n        ),\n        h(XPMeter),\n        h('div', { className: 'status-item' },\n            h('div', { className: 'status-item-header' },\n                h('span', { className: 'status-item-label' }, 'Credits'),\n                h('span', { className: 'status-item-value' }, characterStats.credits.toLocaleString())\n            )\n        ),\n        h('div', { className: 'status-item' },\n            h('div', { className: 'status-item-header' },\n                h('span', { className: 'status-item-label' }, 'Moral'),\n                h('span', { className: `status-item-value ${getMoralityClass(characterStats.morality)}` }, characterStats.morality)\n            )\n        ),\n        Object.entries(characterStats.reputation).map(([faction, value]) =>\n            h(ReputationMeter, { key: faction, faction, value })\n        )\n    );\n};"
    },
    {
      "path": "src/components/GalaxyMap.js",
      "content": "\nimport { h } from 'preact';\n\nconst sectors = [\n    { id: 'alpha', x: 150, y: 120 },\n    { id: 'beta', x: 400, y: 80 },\n    { id: 'gamma', x: 650, y: 150 },\n    { id: 'delta', x: 180, y: 450 },\n    { id: 'epsilon', x: 450, y: 480 },\n    { id: 'zeta', x: 700, y: 400 },\n];\n\nconst paths = [\n    { from: 'alpha', to: 'beta' },\n    { from: 'alpha', to: 'delta' },\n    { from: 'beta', to: 'gamma' },\n    { from: 'gamma', to: 'zeta' },\n    { from: 'delta', to: 'epsilon' },\n    { from: 'epsilon', to: 'zeta' },\n    { from: 'beta', to: 'epsilon' },\n];\n\nconst SectorNode = ({ sector, isActive, isCompleted }) => {\n    const className = `map-node ${isActive ? 'active' : ''} ${isCompleted ? 'completed' : ''}`;\n    return h('g', { id: `node-${sector.id}`, className, transform: `translate(${sector.x}, ${sector.y})` },\n        h('circle', { className: 'map-node-bg', r: 50 }),\n        h('text', { className: 'map-node-label', y: 5 }, sector.id.toUpperCase())\n    );\n};\n\nexport const GalaxyMap = ({ activeSectors, completedSectors }) => {\n    const sectorMap = sectors.reduce((acc, sec) => ({...acc, [sec.id]: sec }), {});\n    \n    return h('svg', { className: 'galaxy-map', viewBox: '0 0 800 600' },\n        h('rect', { className: 'map-bg', width: '100%', height: '100%' }),\n        h('g', { className: 'map-paths' },\n            paths.map(p => h('line', {\n                className: 'map-path',\n                x1: sectorMap[p.from].x,\n                y1: sectorMap[p.from].y,\n                x2: sectorMap[p.to].x,\n                y2: sectorMap[p.to].y\n            }))\n        ),\n        h('g', { className: 'map-nodes' },\n            sectors.map(sector => h(SectorNode, {\n                sector,\n                isActive: activeSectors.includes(sector.id),\n                isCompleted: completedSectors.includes(sector.id),\n            }))\n        )\n    );\n};"
    },
    {
      "path": "src/components/Icon.js",
      "content": "\nimport { h } from 'preact';\n\nexport const Icon = ({ name, size = 20, className = '' }) => {\n    const iconMap = {\n        user: h('path', { d: \"M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z\" }),\n        chart: h('path', { d: \"M5 9.2h3V19H5zM10.6 5h3v14h-3zm5.6 8h3v6h-3z\" }),\n        faction: h('path', { d: \"M12 2L4.5 5 12 8l7.5-3L12 2zm0 18l-7.5-3v-9l7.5 3v9zM12 8l-7.5 3 7.5 3 7.5-3-7.5-3z\" }),\n        dialogue: h('path', { d: \"M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z\" }),\n        credits: h('path', {d: \"M15 18H9V6h6v12zm2-14H7v16h10V4zM3 20h18v2H3v-2z\" }),\n        morality: h('path', { d: \"M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z\"}),\n        reputation: h('path', { d: \"M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z\"}),\n        xp: h('path', { d: \"M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z\"}),\n        lock: h('path', {d: \"M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zM9 8V6c0-1.66 1.34-3 3-3s3 1.34 3 3v2H9z\"}),\n        bug: h('path', {d: \"M20 8h-2.81c-.45-.78-1.07-1.45-1.82-1.96L17 4.41 15.59 3l-2.17 2.17C12.96 5.06 12.49 5 12 5s-.96.06-1.42.17L8.41 3 7 4.41l1.62 1.63C7.88 6.55 7.26 7.22 6.81 8H4v2h2.09c-.05.33-.09.66-.09 1v1H4v2h2v1c0 .34.04.67.09 1H4v2h2.81c.45.78 1.07 1.45 1.82 1.96L7 19.59 8.41 21l2.17-2.17c.46.11.93.17 1.42.17s.96-.06 1.42-.17L15.59 21 17 19.59l-1.62-1.63c.75-.51 1.37-1.18 1.82-1.96H20v-2h-2.09c.05-.33.09-.66-.09-1v-1h2v-2h-2v-1c0-.34-.04-.67-.09-1H20V8zm-6 8h-4v-2h4v2zm0-4h-4v-2h4v2z\"}),\n        devops: h('path', {d: \"M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69-.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49 1c.52.4 1.08.73 1.69-.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49.42l.38 2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z\"}),\n        science: h('path', {d: \"M18.5 3H6c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM6 5h12v2.53l-6 4.67-6-4.67V5zm12 12H6v-2.53l6-4.67 6 4.67V17z\"}),\n        folder: h('path', {d: \"M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z\"}),\n        inventory: h('path', {d: \"M20 6h-4V4c0-1.1-.9-2-2-2h-4c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v11c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM14 6H10V4h4v2z\"}),\n        chip: h('path', { d: \"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 18H7v-2h2v2zm0-4H7v-2h2v2zm0-4H7V8h2v2zm4 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V8h2v2zm4 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V8h2v2z\"}),\n        link: h('path', { d: \"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z\"}),\n    };\n    return h('svg', { xmlns: \"http://www.w3.org/2000/svg\", viewBox: \"0 0 24 24\", fill: \"currentColor\", width: size, height: size, className: `icon icon-${name.toLowerCase()} ${className}` },\n        iconMap[name.toLowerCase()] || h('path', {d: 'M0 0h24v24H0z'}) // default empty\n    );\n};"
    },
    {
      "path": "src/components/LoadingSpinner.js",
      "content": "\nimport { h } from 'preact';\n\nexport const LoadingSpinner = () => {\n    return h('div', { className: \"spinner-container\", 'aria-label': \"Loading\" },\n        h('div', { className: \"spinner\" }),\n        h('p', { style: { fontFamily: 'var(--font-display)' } }, 'Empfange Übertragung...')\n    );\n};"
    },
    {
      "path": "src/components/MainMenu.js",
      "content": "\n\n\nimport { h } from 'preact';\nimport { useStore } from '../store/AppContext.js';\n\nexport const MainMenu = () => {\n    const { actions, profiles, activeProfileId } = useStore();\n    \n    const hasProfiles = profiles.length > 0;\n    const canContinue = !!activeProfileId;\n\n    return h('div', { className: 'main-menu-container' },\n        h('h1', { className: 'main-menu-title' }, 'ScriptDaX OS'),\n        h('nav', { className: 'main-menu-nav' },\n            h('button', { className: 'main-menu-button', onClick: actions.startNewGame }, 'Neues Spiel'),\n            h('button', { className: 'main-menu-button', onClick: () => { if(canContinue) actions.continueLastSession() }, disabled: !canContinue }, 'Fortfahren'),\n            h('button', { className: 'main-menu-button', onClick: () => actions.setGameState('profile-select'), disabled: !hasProfiles }, 'Profil laden'),\n            h('button', { className: 'main-menu-button', onClick: () => actions.setGameState('research-lab'), disabled: !canContinue }, 'Forschung & Entwicklung'),\n            h('button', { className: 'main-menu-button', onClick: () => actions.setGameState('codex') }, 'Kodex'),\n            h('button', { className: 'main-menu-button', onClick: () => actions.setGameState('market-analysis') }, 'Marktanalyse'),\n            h('button', { className: 'main-menu-button', onClick: () => actions.setGameState('beta-management') }, 'Beta-Management'),\n            h('button', { className: 'main-menu-button', onClick: () => actions.setGameState('project-chronicle') }, 'Projekt-Chronik'),\n            h('button', { className: 'main-menu-button', onClick: () => actions.setGameState('linux-initiative') }, 'Linux-Initiative'),\n            h('button', { className: 'main-menu-button', onClick: () => actions.setGameState('settings') }, 'Optionen'),\n            h('button', { className: 'main-menu-button', onClick: () => actions.setGameState('credits') }, 'Credits'),\n            h('button', { className: 'main-menu-button', onClick: () => window.close() }, 'Beenden')\n        )\n    );\n};"
    },
    {
      "path": "src/components/Settings.js",
      "content": "\nimport { h } from 'preact';\nimport { useStore } from '../store/AppContext.js';\nimport { Slider } from './settings/Slider.js';\nimport { OperatorData } from './settings/OperatorData.js';\nimport { allThemes } from '../config/themes.js';\nimport { Icon } from './Icon.js';\n\nconst ThemeSelector = () => {\n    const { activeProfile, actions } = useStore();\n    if (!activeProfile) return null;\n\n    const { unlockedThemes = ['default'], activeTheme = 'default' } = activeProfile;\n\n    return h('div', { className: 'theme-selector-grid' },\n        allThemes.map(theme => {\n            const isUnlocked = unlockedThemes.includes(theme.id);\n            const cardClasses = `theme-card ${activeTheme === theme.id ? 'active' : ''} ${!isUnlocked ? 'locked' : ''}`;\n\n            return h('div', {\n                key: theme.id,\n                className: cardClasses,\n                onClick: () => isUnlocked && actions.setTheme(theme.id),\n                title: isUnlocked ? `Theme \"${theme.name}\" aktivieren` : `Gesperrt: ${theme.unlockCondition}`\n            },\n                h('div', { className: 'theme-card-name' }, theme.name),\n                h('div', { className: 'theme-card-preview' },\n                    Object.values(theme.previewColors).map(color =>\n                        h('div', { className: 'theme-color-swatch', style: { backgroundColor: color } })\n                    )\n                ),\n                !isUnlocked && h(Icon, { name: 'lock', size: 24, className: 'theme-locked-icon' })\n            );\n        })\n    );\n};\n\nexport const Settings = () => {\n    const { settings, actions } = useStore();\n\n    const handleInput = (key, e) => {\n        actions.setSettings({ ...settings, [key]: parseInt(e.target.value, 10) });\n    };\n\n    return h('div', { className: 'settings-container' },\n        h('h1', { className: 'settings-title' }, 'Optionen'),\n        h('div', { className: 'settings-list' },\n            h(Slider, {\n                label: 'Musik-Lautstärke',\n                value: settings.musicVolume,\n                onInput: (e) => handleInput('musicVolume', e)\n            }),\n            h(Slider, {\n                label: 'SFX-Lautstärke',\n                value: settings.sfxVolume,\n                onInput: (e) => handleInput('sfxVolume', e)\n            }),\n            h(Slider, {\n                label: 'Stimmen-Lautstärke',\n                value: settings.voiceVolume,\n                onInput: (e) => handleInput('voiceVolume', e)\n            })\n        ),\n        h('h2', { className: 'setting-section-title' }, 'UI-Anpassung'),\n        h(ThemeSelector),\n        h(OperatorData),\n        h('div', { style: { marginTop: '2rem', paddingTop: '1.5rem', borderTop: '1px solid var(--border-color)', display: 'flex', justifyContent: 'flex-end' } },\n            h('button', { className: 'button secondary', onClick: () => actions.setGameState('main-menu') }, 'Zurück zum Menü')\n        )\n    );\n};"
    },
    {
      "path": "src/components/Credits.js",
      "content": "\nimport { h } from 'preact';\nimport { useState, useEffect } from 'preact/hooks';\nimport { useStore } from '../store/AppContext.js';\n\nexport const Credits = () => {\n    const { actions } = useStore();\n    const [spotlightStyle, setSpotlightStyle] = useState({});\n\n    useEffect(() => {\n        const handleMouseMove = (e) => {\n            setSpotlightStyle({\n                background: `radial-gradient(circle 400px at ${e.clientX}px ${e.clientY}px, rgba(0, 229, 255, 0.15), transparent 80%)`,\n            });\n        };\n\n        window.addEventListener('mousemove', handleMouseMove);\n\n        return () => {\n            window.removeEventListener('mousemove', handleMouseMove);\n        };\n    }, []);\n\n    // This component bypasses the standard container to take over the whole screen\n    return h('div', { className: 'credits-view-container', style: spotlightStyle },\n        h('div', { className: 'credits-spotlight-content' },\n            h('h1', { className: 'credits-main-title' }, 'Credits'),\n            \n            h('div', { className: 'credits-card' },\n                h('h2', { className: 'credits-special-thanks' }, 'Ein ganz besonderer Dank an'),\n                h('p', { className: 'credits-name' }, 'Mustafa Ögretmen (Musti)'),\n                h('div', { className: 'credits-tags' },\n                    h('span', { className: 'credit-tag visionary' }, 'Visionär'),\n                    h('span', { className: 'credit-tag friend' }, 'Freund'),\n                    h('span', { className: 'credit-tag betatester' }, 'Sponsor')\n                )\n            ),\n             h('div', { className: 'credits-card' },\n                h('h2', { className: 'credits-special-thanks' }, 'Danksagung'),\n                h('p', { className: 'credits-name' }, 'Stephan Reinheimer (Of)'),\n                h('div', { className: 'credits-tags' },\n                    h('span', { className: 'credit-tag mitbewohner' }, 'Mitbewohner'),\n                    h('span', { className: 'credit-tag mentor' }, 'Mentor'),\n                    h('span', { className: 'credit-tag betatester' }, 'Betatester'),\n                    h('span', { className: 'credit-tag friend' }, 'Freund')\n                )\n            ),\n      \n            h('button', { \n                onClick: () => actions.setGameState('main-menu'), \n                className: 'credits-back-button',\n            }, 'Zurück zum Menü')\n        )\n    );\n};"
    },
    {
      "path": "src/store/AppContext.js",
      "content": "\nimport { createContext, h } from 'preact';\nimport { useContext } from 'preact/hooks';\nimport { useAppStore as useAppStoreHook } from './useAppStore.js';\n\nexport const AppContext = createContext(null);\n\nexport const useStore = () => {\n    const context = useContext(AppContext);\n    if (context === null) {\n        throw new Error(\"useStore must be used within an AppContext.Provider. This is a critical error in the application setup.\");\n    }\n    return context;\n};\n\n// This hook is now only used in the main entry file to initialize the store.\nexport const useAppStore = useAppStoreHook;"
    },
    {
      "path": "src/components/CommsFeed.js",
      "content": "\nimport { h } from 'preact';\nimport { useStore } from '../store/AppContext.js';\n\nexport const CommsFeed = () => {\n    const { events } = useStore();\n    return h('div', { className: 'comms-feed' },\n        h('h2', { className: 'comms-feed-title' }, 'Kommunikations-Feed'),\n        h('div', { className: 'comms-feed-list' },\n            events.map(event => h('p', { key: event.id, className: 'comms-feed-item', dangerouslySetInnerHTML: { __html: event.message } }))\n        )\n    );\n};"
    },
    {
      "path": "src/config/origins.js",
      "content": "\nexport const origins = [\n    {\n        id: 'federation_graduate',\n        name: 'Absolvent der Föderationsakademie',\n        description: 'Diszipliniert und prinzipientreu, mit starker Loyalität zur Föderation.',\n        modifiers: {\n            credits: 0,\n            morality: 5,\n            reputation: {\n                \"Stellar Federation\": 15,\n                \"Mars Conglomerate\": -5,\n                \"Jupiter Collective\": 0,\n            }\n        }\n    },\n    {\n        id: 'mars_heir',\n        name: 'Konzernerbe vom Mars',\n        description: 'Reich und einflussreich, mit den Ressourcen des Mars-Konglomerats im Rücken.',\n        modifiers: {\n            credits: 500,\n            morality: -10,\n            reputation: {\n                \"Stellar Federation\": -5,\n                \"Mars Conglomerate\": 15,\n                \"Jupiter Collective\": -5,\n            }\n        }\n    },\n    {\n        id: 'jupiter_scientist',\n        name: 'Wissenschaftler des Jupiter-Kollektivs',\n        description: 'Idealistisch und brillant, konzentriert auf Entdeckung und das Wohl aller.',\n        modifiers: {\n            credits: -100,\n            morality: 10,\n            reputation: {\n                \"Stellar Federation\": 0,\n                \"Mars Conglomerate\": -5,\n                \"Jupiter Collective\": 15,\n            }\n        }\n    }\n];"
    },
    {
      "path": "src/components/CharacterCreator.js",
      "content": "\nimport { h } from 'preact';\nimport { useState } from 'preact/hooks';\nimport { useStore } from '../store/AppContext.js';\nimport { origins } from '../config/origins.js';\nimport { OriginDisplay } from './character_creator/OriginDisplay.js';\n\nexport const CharacterCreator = () => {\n    const { actions } = useStore();\n    const [name, setName] = useState('');\n    const [selectedOriginId, setSelectedOriginId] = useState(origins[0].id);\n    const [displayedOriginId, setDisplayedOriginId] = useState(origins[0].id);\n    const [learningGoalKeyword, setLearningGoalKeyword] = useState('');\n    const [learningGoalDescription, setLearningGoalDescription] = useState('');\n\n    const handleConfirm = () => {\n        if (name.trim() && selectedOriginId) {\n            const selectedOrigin = origins.find(o => o.id === selectedOriginId);\n            const learningGoal = {\n                keyword: learningGoalKeyword.trim(),\n                description: learningGoalDescription.trim(),\n            };\n            actions.confirmCharacterCreation({ name: name.trim(), origin: selectedOrigin, learningGoal });\n        }\n    };\n\n    const isConfirmDisabled = !name.trim() || !selectedOriginId;\n    const displayedOrigin = origins.find(o => o.id === displayedOriginId);\n\n    return h('div', { className: 'creator-container' },\n        h('h1', { className: 'creator-title' }, 'Charakterprofil Erstellen'),\n        h('form', { className: 'creator-form', onSubmit: e => { e.preventDefault(); if (!isConfirmDisabled) handleConfirm(); } },\n            h('div', { className: 'creator-input-group' },\n                h('label', { className: 'creator-label', for: 'characterName' }, 'Name des Operators'),\n                h('input', {\n                    id: 'characterName',\n                    className: 'creator-input',\n                    type: 'text',\n                    value: name,\n                    onInput: e => setName(e.target.value),\n                    placeholder: 'Geben Sie Ihren Namen ein...',\n                    maxLength: 25,\n                })\n            ),\n            h('div', { className: 'creator-input-group' },\n                h('label', { className: 'creator-label' }, 'Herkunft Wählen'),\n                 h('div', { className: 'creator-origins-container' },\n                    h('ul', { className: 'origins-list' },\n                        origins.map(origin => h('li', {\n                            key: origin.id,\n                            className: `origin-list-item ${selectedOriginId === origin.id ? 'active' : ''}`,\n                            onClick: () => setSelectedOriginId(origin.id),\n                            onMouseOver: () => setDisplayedOriginId(origin.id),\n                        }, `> ${origin.name}`))\n                    ),\n                    h(OriginDisplay, { origin: displayedOrigin })\n                )\n            ),\n            h('div', { className: 'creator-input-group' },\n                h('label', { className: 'creator-label' }, 'Lernziel Definieren (Optional)'),\n                h('div', { className: 'creator-input-group', style: { gap: '0.75rem' } },\n                    h('input', {\n                        id: 'learningGoalKeyword',\n                        className: 'creator-input',\n                        type: 'text',\n                        value: learningGoalKeyword,\n                        onInput: e => setLearningGoalKeyword(e.target.value),\n                        placeholder: 'z.B. JavaScript-Schleifen, CSS-Flexbox',\n                        maxLength: 50,\n                    }),\n                    h('textarea', {\n                        id: 'learningGoalDescription',\n                        className: 'creator-textarea',\n                        value: learningGoalDescription,\n                        onInput: e => setLearningGoalDescription(e.target.value),\n                        placeholder: 'Beschreiben Sie, was Sie lernen oder üben möchten...',\n                        rows: 3,\n                    })\n                )\n            ),\n            h('div', { className: 'creator-actions' },\n                 h('button', {\n                    type: 'button',\n                    className: 'button secondary',\n                    onClick: () => actions.setGameState('main-menu'),\n                }, 'Zurück zum Menü'),\n                h('button', {\n                    type: 'submit',\n                    className: 'button',\n                    disabled: isConfirmDisabled,\n                }, 'Profil Bestätigen & Starten')\n            )\n        )\n    );\n};"
    },
    {
      "path": "src/components/ProfileSelector.js",
      "content": "\nimport { h } from 'preact';\nimport { useState, useEffect } from 'preact/hooks';\nimport { useStore } from '../store/AppContext.js';\nimport { Icon } from './Icon.js';\n\n// Create a self-contained delete button component to manage its state\nconst DeleteButton = ({ profile }) => {\n    const { actions } = useStore();\n    const [confirmState, setConfirmState] = useState('idle'); // 'idle', 'confirming'\n    const [countdown, setCountdown] = useState(5);\n\n    useEffect(() => {\n        let timer;\n        if (confirmState === 'confirming' && countdown > 0) {\n            timer = setTimeout(() => setCountdown(c => c - 1), 1000);\n        } else if (confirmState === 'confirming' && countdown === 0) {\n            setConfirmState('idle'); // Reset if time runs out\n        }\n        return () => clearTimeout(timer);\n    }, [confirmState, countdown]);\n\n    const handleInitialClick = (e) => {\n        e.stopPropagation(); // Prevent the card's onClick from firing\n        if (window.confirm(`Sind Sie sicher, dass Sie das Profil '${profile.characterStats.displayName}' löschen möchten? Dies kann nicht rückgängig gemacht werden.`)) {\n            setConfirmState('confirming');\n            setCountdown(5);\n        }\n    };\n    \n    const handleConfirmClick = (e) => {\n        e.stopPropagation();\n        actions.deleteProfile(profile.id);\n        setConfirmState('idle');\n    };\n\n    if (confirmState === 'confirming') {\n        return h('button', {\n            className: 'button danger',\n            onClick: handleConfirmClick,\n        }, `Bestätigen (${countdown}s)`);\n    }\n\n    return h('button', {\n        className: 'button secondary danger',\n        onClick: handleInitialClick,\n    }, 'Löschen');\n};\n\nexport const ProfileSelector = () => {\n    const { profiles, actions } = useStore();\n\n    // Sort profiles by most recently played\n    const sortedProfiles = [...profiles].sort((a, b) => new Date(b.lastPlayed) - new Date(a.lastPlayed));\n\n    return h('div', { className: 'profile-selector-container' },\n        h('h1', { className: 'profile-selector-title' }, 'Profil auswählen'),\n        h('div', { className: 'profile-list' },\n            sortedProfiles.length > 0 ? (\n                sortedProfiles.map(profile => {\n                    const cardClasses = [\n                        'profile-card',\n                        profile.isDeveloper ? 'developer' : '',\n                        profile.isBetaTester ? 'beta-tester' : '',\n                    ].filter(Boolean).join(' ');\n\n                    return h('div', { key: profile.id, className: cardClasses, onClick: () => actions.loadProfile(profile.id) },\n                        h('div', { className: 'profile-info' },\n                            (profile.isDeveloper || profile.isBetaTester) && h(Icon, {\n                                name: profile.isDeveloper ? 'devops' : 'science',\n                                size: 24,\n                                title: profile.isDeveloper ? 'Entwicklerprofil' : 'Beta-Tester-Profil',\n                            }),\n                            h('div', null,\n                                h('h3', null, profile.characterStats.displayName),\n                                h('p', null, `Zuletzt gespielt: ${new Date(profile.lastPlayed).toLocaleString()}`)\n                            )\n                        ),\n                        h('div', { className: 'profile-actions' },\n                            h('button', {\n                                className: 'button',\n                                onClick: (e) => {\n                                    e.stopPropagation();\n                                    actions.loadProfile(profile.id)\n                                },\n                            }, 'Laden'),\n                            h(DeleteButton, { profile })\n                        )\n                    )\n                })\n            ) : (\n                h('p', { className: 'no-profiles-message' }, 'Keine gespeicherten Profile gefunden. Starten Sie ein neues Spiel.')\n            )\n        ),\n        h('div', { style: { marginTop: '2rem', paddingTop: '1.5rem', borderTop: '1px solid var(--border-color)', display: 'flex', justifyContent: 'flex-end' } },\n            h('button', { className: 'button secondary', onClick: () => actions.setGameState('main-menu') }, 'Zurück zum Menü')\n        )\n    );\n};"
    },
    {
      "path": "src/config/lore.js",
      "content": "\nexport const factions = [\n    {\n        id: 'stellar_federation',\n        name: 'Stellare Föderation',\n        description: 'Eine riesige, demokratische Regierungsform, die sich über Hunderte von Systemen erstreckt. Sie legt Wert auf Ordnung, Diplomatie und kollektive Sicherheit. Ihre Kritiker werfen ihr bürokratische Schwerfälligkeit und moralische Selbstgerechtigkeit vor.'\n    },\n    {\n        id: 'mars_conglomerate',\n        name: 'Mars-Konglomerat',\n        description: 'Ein rücksichtsloser Zusammenschluss von Hyper-Korporationen mit Sitz auf dem Mars. Das Konglomerat wird von Profit, technologischer Überlegenheit und der Ausbeutung von Ressourcen angetrieben. Effizienz steht über Ethik.'\n    },\n    {\n        id: 'jupiter_collective',\n        name: 'Jupiter-Kollektiv',\n        description: 'Eine lose Allianz von Wissenschaftlern, Ingenieuren und Idealisten, die in den schwebenden Städten des Jupiter leben. Sie widmen sich dem freien Austausch von Wissen, radikaler wissenschaftlicher Forschung und der Verbesserung der Menschheit, oft unter Missachtung von Sicherheitsvorschriften.'\n    }\n];"
    },
    {
      "path": "src/components/Codex.js",
      "content": "\nimport { h } from 'preact';\nimport { useState } from 'preact/hooks';\nimport { useStore } from '../store/AppContext.js';\nimport { factions as factionData } from '../config/lore.js';\n\nconst FactionCard = ({ faction }) => {\n    return h('div', { className: 'faction-card' },\n        h('h2', { className: 'faction-title' }, faction.name),\n        h('p', { className: 'faction-description' }, faction.description)\n    );\n};\n\nconst NpcCard = ({ npc }) => {\n    return h('div', { className: 'npc-card' },\n        h('h2', { className: 'npc-name' }, npc.name),\n        h('p', { className: 'npc-faction' }, npc.faction)\n    );\n};\n\nexport const Codex = () => {\n    const { actions, allDiscoveredNPCs } = useStore();\n    const [activeTab, setActiveTab] = useState('factions');\n\n    return h('div', { className: 'codex-container' },\n        h('h1', { className: 'codex-title' }, 'Kodex'),\n        h('div', { className: 'codex-tabs' },\n            h('button', {\n                className: `codex-tab-button ${activeTab === 'factions' ? 'active' : ''}`,\n                onClick: () => setActiveTab('factions')\n            }, 'Fraktionen'),\n            h('button', {\n                className: `codex-tab-button ${activeTab === 'npcs' ? 'active' : ''}`,\n                onClick: () => setActiveTab('npcs')\n            }, 'NPC-Archiv')\n        ),\n        h('div', { className: 'codex-content' },\n            activeTab === 'factions' && factionData.map(faction =>\n                h(FactionCard, { key: faction.id, faction })\n            ),\n            activeTab === 'npcs' && (\n                allDiscoveredNPCs.length > 0\n                    ? allDiscoveredNPCs.map(npc => h(NpcCard, { key: npc.name, npc }))\n                    : h('p', { className: 'no-profiles-message' }, 'Noch keine NPCs entdeckt. Spiele Missionen, um Informationen zu sammeln.')\n            )\n        ),\n        h('div', { className: 'codex-footer' },\n            h('button', {\n                className: 'button secondary',\n                onClick: () => actions.setGameState('main-menu'),\n            }, 'Zurück zum Menü')\n        )\n    );\n};"
    },
    {
      "path": "src/changelog.md",
      "content": ""
    },
    {
      "path": "src/components/Version.js",
      "content": "\n\nimport { h } from 'preact';\n\nexport const Version = () => {\n    const version = '5.1.0'; // Base version from package.json\n    const mode = import.meta.env.MODE; // 'development', 'production', etc.\n    \n    let displayVersion = version;\n    if (mode === 'development') {\n        displayVersion = `${version}-dev`;\n    }\n\n    return h('div', { className: 'version-display' }, `v${displayVersion}`);\n};"
    },
    {
      "path": "src/components/BetaKeyPrompt.js",
      "content": "\nimport { h } from 'preact';\nimport { useState } from 'preact/hooks';\nimport { useStore } from '../store/AppContext.js';\n\nexport const BetaKeyPrompt = () => {\n    const { actions, betaKeyError } = useStore();\n    const [key, setKey] = useState('');\n\n    const handleSubmit = (e) => {\n        e.preventDefault();\n        if (key.trim()) {\n            actions.validateAndCompleteBetaCreation(key.trim());\n        }\n    };\n\n    return h('div', { className: 'beta-key-prompt-overlay' },\n        h('form', { className: 'beta-key-prompt-container', onSubmit: handleSubmit },\n            h('h2', { className: 'beta-key-prompt-title' }, 'Beta-Zugang erforderlich'),\n            h('p', null, 'Für dieses Profil wird ein gültiger Beta-Lizenzschlüssel benötigt.'),\n            h('input', {\n                className: 'beta-key-prompt-input',\n                type: 'text',\n                value: key,\n                onInput: (e) => setKey(e.target.value.toUpperCase()),\n                placeholder: 'LIZENZSCHLÜSSEL',\n                autofocus: true,\n            }),\n            betaKeyError && h('p', { className: 'beta-key-prompt-error' }, betaKeyError),\n            h('div', { className: 'beta-key-prompt-actions' },\n                h('button', {\n                    type: 'button',\n                    className: 'button secondary',\n                    onClick: actions.cancelBetaCreation,\n                }, 'Abbrechen'),\n                h('button', {\n                    type: 'submit',\n                    className: 'button',\n                    style: { backgroundColor: 'var(--accent-beta)' },\n                    disabled: !key.trim(),\n                }, 'Bestätigen')\n            )\n        )\n    );\n};"
    },
    {
      "path": "src/components/PreloadScreen.js",
      "content": "\nimport { h } from 'preact';\nimport { useStore } from '../store/AppContext.js';\nimport { audioService } from '../services/audioService.js';\n\nexport const PreloadScreen = () => {\n    const { actions, activeProfileId } = useStore();\n\n    const hasLastSession = !!activeProfileId;\n    \n    const handleContinue = () => {\n        if (!hasLastSession) return;\n        audioService.playClickSound();\n        actions.continueLastSession();\n    };\n    \n    const handleMainMenu = () => {\n        audioService.playClickSound();\n        actions.goToMainMenu();\n    };\n\n    return h('div', { className: 'preload-container' },\n        h('h1', { className: 'preload-title' }, 'ScriptDaX OS'),\n        h('div', { className: 'preload-options' },\n            h('div', {\n                className: `preload-option-card ${!hasLastSession ? 'disabled' : ''}`,\n                onClick: handleContinue,\n            },\n                h('h3', null, 'Letzte Sitzung fortsetzen'),\n                h('p', null, 'Direkt ins Spiel mit dem zuletzt aktiven Operator.')\n            ),\n            h('div', {\n                className: 'preload-option-card',\n                onClick: handleMainMenu,\n            },\n                h('h3', null, 'Profile verwalten & Starten'),\n                h('p', null, 'Zum Hauptmenü, um Profile zu laden oder zu erstellen.')\n            )\n        )\n    );\n};"
    },
    {
      "path": "src/components/SystemCheck.js",
      "content": "\n\n\nimport { h } from 'preact';\nimport { useState, useEffect, useMemo } from 'preact/hooks';\nimport { useStore } from '../store/AppContext.js';\nimport { Icon } from './Icon.js';\nimport { fullSourceCode } from '../config/source_code.js';\n\n// Manifest updated for the final clean architecture.\n// This list is the \"single source of truth\" for the contents of the `src` directory.\nconst fileManifest = {\n  'components/App.js': {},\n  'components/BetaKeyPrompt.js': {},\n  'components/BetaManagement.js': {},\n  'components/BetaProgramCard.js': {},\n  'components/CharacterCreator.js': {},\n  'components/CharacterStatus.js': {},\n  'components/Codex.js': {},\n  'components/CommsFeed.js': {},\n  'components/ControlPanel.js': {},\n  'components/CostBenefitAnalysis.js': {},\n  'components/Credits.js': {},\n  'components/Dashboard.js': {},\n  'components/DebugConsole.js': {},\n  'components/DebugPanel.js': {},\n  'components/FixLogCard.js': {},\n  'components/FixVerificationView.js': {},\n  'components/GalaxyMap.js': {},\n  'components/Icon.js': {},\n  'components/Inventory.js': {},\n  'components/ItemTooltip.js': {},\n  'components/LandingPage.js': {},\n  'components/LinuxDistribution.js': {},\n  'components/LoadingScreen.js': {},\n  'components/LoadingSpinner.js': {},\n  'components/MainMenu.js': {},\n  'components/MarketAnalysis.js': {},\n  'components/Notifications.js': {},\n  'components/PreloadScreen.js': {},\n  'components/ProfileSelector.js': {},\n  'components/ProjectChronicle.js': {},\n  'components/QuestTerminal.js': {},\n  'components/ReportCard.js': {},\n  'components/ReportModal.js': {},\n  'components/ReportViewer.js': {},\n  'components/ResearchLab.js': {},\n  'components/Settings.js': {},\n  'components/SystemCheck.js': {},\n  'components/TechNode.js': {},\n  'components/Version.js': {},\n  'components/character_creator/Modifier.js': {},\n  'components/character_creator/OriginDisplay.js': {},\n  'components/character_creator/useTypingEffect.js': {},\n  'components/settings/DeleteActiveProfileButton.js': {},\n  'components/settings/OperatorData.js': {},\n  'components/settings/Slider.js': {},\n  'config/beta_programs.js': {},\n  'config/fallbackQuests.js': {},\n  'config/lore.js': {},\n  'config/origins.js': {},\n  'config/prompts.js': {},\n  'config/source_code.js': {},\n  'config/tech_tree.js': {},\n  'config/themes.js': {},\n  'services/aiAnalystService.js': {},\n  'services/aiApplicationStrategistService.js': {},\n  'services/aiBiographerService.js': {},\n  'services/aiCommunityManagerService.js': {},\n  'services/aiCostBenefitService.js': {},\n  'services/aiLinuxAdvocateService.js': {},\n  'services/aiMentalCoachService.js': {},\n  'services/aiProjectManagerService.js': {},\n  'services/aiSecurityAuditorService.js': {},\n  'services/aiService.js': {},\n  'services/audioService.js': {},\n  'services/persistenceService.js': {},\n  'services/proxyHelper.js': {},\n  'services/starfieldService.js': {},\n  'services/virtualTeamService.js': {},\n  'store/AppContext.js': {},\n  'store/helpers.js': {},\n  'store/initialState.js': {},\n  'store/reducer.js': {},\n  'store/useAppStore.js': {},\n  'index.css': {},\n  'index.html': {},\n  'index.js': {},\n};\n\nexport const SystemCheck = () => {\n    const { actions } = useStore();\n    const [checkedFiles, setCheckedFiles] = useState([]);\n    const [isChecking, setIsChecking] = useState(false);\n    const [isExtracting, setIsExtracting] = useState(false);\n\n    const allFiles = useMemo(() => Object.keys(fileManifest).sort(), []);\n\n    useEffect(() => {\n        setIsChecking(true);\n        const interval = setInterval(() => {\n            setCheckedFiles(prev => {\n                if (prev.length < allFiles.length) {\n                    return [...prev, allFiles[prev.length]];\n                }\n                clearInterval(interval);\n                setIsChecking(false);\n                return prev;\n            });\n        }, 30);\n        return () => clearInterval(interval);\n    }, [allFiles]);\n    \n    const handleExportReport = () => {\n        if (isChecking) return;\n        \n        const details = Object.entries(fileManifest).map(([path, info]) => ({\n            path,\n            status: 'PRESENT'\n        }));\n\n        const report = {\n            reportGeneratedAt: new Date().toISOString(),\n            summary: {\n                totalFiles: details.length,\n                status: 'Prüfung abgeschlossen'\n            },\n            details\n        };\n\n        const jsonString = JSON.stringify(report, null, 2);\n        const blob = new Blob([jsonString], { type: 'application/json' });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `scriptdax_system_check_${new Date().toISOString().split('T')[0]}.json`;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    };\n\n    const handleExtractSource = () => {\n        if (isExtracting || isChecking) return;\n        setIsExtracting(true);\n        actions.showNotification('Starte Quellcode-Extraktion... Dies kann einen Moment dauern.', 'info');\n\n        setTimeout(() => {\n            try {\n                const dataToExport = {\n                    projectName: 'ScriptDaX OS',\n                    extractionTimestamp: new Date().toISOString(),\n                    directive: \"Protokoll-Anforderung für Quellcode-Extraktion\",\n                    sourceFiles: fullSourceCode,\n                };\n\n                const jsonString = JSON.stringify(dataToExport, null, 2);\n                const blob = new Blob([jsonString], { type: 'application/json' });\n                const url = URL.createObjectURL(blob);\n                const a = document.createElement('a');\n                a.href = url;\n                a.download = `scriptdax_os_source_code_${new Date().toISOString().split('T')[0]}.json`;\n                document.body.appendChild(a);\n                a.click();\n                document.body.removeChild(a);\n                URL.revokeObjectURL(url);\n                \n                actions.showNotification('Quellcode-Extraktion erfolgreich abgeschlossen.', 'success');\n            } catch (e) {\n                console.error(\"Source code extraction failed:\", e);\n                actions.showNotification(`Quellcode-Extraktion fehlgeschlagen: ${e.message}`, 'error');\n            } finally {\n                setIsExtracting(false);\n            }\n        }, 100);\n    };\n\n    const groupedFiles = allFiles.reduce((acc, path) => {\n        const dir = path.includes('/') ? path.substring(0, path.lastIndexOf('/')) : '.';\n        if (!acc[dir]) {\n            acc[dir] = [];\n        }\n        acc[dir].push(path);\n        return acc;\n    }, {});\n    \n    const totalFiles = allFiles.length;\n    \n    const SummaryMessage = () => {\n        if (isChecking) {\n            return `Prüfe ${checkedFiles.length} / ${totalFiles} Dateien...`;\n        }\n        return h('span', {className: 'ok'}, `Systemprüfung abgeschlossen. Alle ${totalFiles} Quelldateien im 'src'-Verzeichnis sind intakt.`);\n    };\n\n    return h('div', { className: 'system-check-container' },\n        h('h1', { className: 'system-check-title' }, 'Systemintegritätsprüfung'),\n         h('p', { style: { color: 'var(--text-secondary)', marginBottom: '1.5rem', lineHeight: '1.5', marginTop: '-1rem' } },\n            'Diese Werkzeuge überprüfen die Anwendungs-Integrität und ermöglichen die Extraktion des kompletten Quellcodes zur externen Analyse.'\n        ),\n        h('div', { className: 'system-check-summary' },\n            h('div', { className: 'system-check-summary-text' }, h(SummaryMessage)),\n            isChecking && h('div', { className: 'spinner', style: { width: '24px', height: '24px', borderWidth: '3px' }})\n        ),\n        h('div', { className: 'system-check-content' },\n            Object.entries(groupedFiles).map(([dir, files]) => h('div', { key: dir, className: 'directory-group' },\n                h('h2', { className: 'directory-title' }, h(Icon, {name: 'folder', size: 16}), ` src/${dir === '.' ? '' : dir + '/'}`),\n                files.map(path => {\n                    const isChecked = checkedFiles.includes(path);\n                    if (!isChecked) return null;\n                    \n                    return h('div', { key: path, className: 'file-entry', style: { animation: 'fadeIn 0.5s' } },\n                        h(Icon, { name: 'reputation', size: 16 }),\n                        h('span', { className: 'file-path' }, path.substring(path.lastIndexOf('/') + 1)),\n                        h('span', { className: 'file-status ok' }, 'PRESENT')\n                    );\n                })\n            ))\n        ),\n        h('div', { className: 'system-check-footer' },\n            h('div', { className: 'system-check-footer-actions'},\n                h('button', {\n                    className: 'button secondary',\n                    onClick: handleExportReport,\n                    disabled: isChecking || isExtracting,\n                }, 'Bericht exportieren'),\n                h('button', {\n                    className: 'button secondary',\n                    onClick: handleExtractSource,\n                    disabled: isChecking || isExtracting,\n                    title: 'Extrahiert den gesamten Anwendungs-Quellcode in eine einzelne JSON-Datei.'\n                }, isExtracting ? 'Extrahiere...' : 'Quellcode extrahieren'),\n                h('button', {\n                    className: 'button secondary',\n                    onClick: () => actions.setGameState('main-menu'),\n                }, 'Zurück zum Menü')\n            )\n        )\n    );\n};"
    },
    {
      "path": "README.md",
      "content": "\n# ScriptDaX OS - Projektdokumentation (Finaler Workflow)\n\nDieses Dokument beschreibt den finalen, stabilen Entwicklungs-Workflow für \"ScriptDaX OS\". Alle bisherigen Startprobleme wurden durch die Umstellung auf diesen Standardprozess behoben.\n\n## 1. Voraussetzung: Node.js\n\nStellen Sie sicher, dass Sie die **LTS-Version von Node.js** installiert haben.\n- **Download:** [https://nodejs.org/](https://nodejs.org/)\n- **Wichtig:** Achten Sie bei der Installation darauf, dass die Option **\"Add to PATH\"** aktiviert ist.\n\n## 2. Der EINZIGE Weg, die Entwicklung zu starten\n\nUm Fehler wie die `main.py`-Fehlermeldung endgültig zu beseitigen, gibt es nur noch einen einzigen, korrekten Weg, die Entwicklungsumgebung zu starten. Verwenden Sie ein Kommandozeilen-Tool wie \"Eingabeaufforderung\" oder \"PowerShell\".\n\n**Schritt 1: Abhängigkeiten installieren**\nÖffnen Sie Ihr Terminal im Projektverzeichnis und führen Sie einmalig aus:\n```bash\nnpm install\n```\nDieser Befehl lädt alle für das Projekt notwendigen Bibliotheken herunter.\n\n**Schritt 2: Entwicklungsserver starten**\nFühren Sie danach im selben Terminal aus:\n```bash\nnpm run dev\n```\nDieses Skript startet den Vite-Entwicklungsserver. Ein Browser-Tab sollte sich automatisch mit der laufenden Anwendung öffnen. Änderungen am Code werden sofort live im Browser angezeigt.\n\n## 3. WICHTIG: Projekt-Bereinigung\n\nUm sicherzustellen, dass keine alten, fehlerhaften Skripte mehr ausgeführt werden, **löschen Sie bitte manuell alle `.bat`-Dateien** (`start.bat`, `setup_and_watch.bat` etc.) und andere veraltete Dateien aus Ihrem Projektordner.\n\n## 4. Sicherheit: API-Proxy-Architektur\n\nDie sichere API-Proxy-Architektur bleibt unverändert. Für die lokale Entwicklung mit API-Zugriff starten Sie das Projekt mit `netlify dev` im Terminal. Die `vite.config.js` ist korrekt konfiguriert, um Anfragen an den lokalen Server weiterzuleiten."
    },
    {
      "path": "DEV_BRIEFING.md",
      "content": "\n# Entwickler-Briefing: Der finale Startprozess\n\nHallo! Willkommen zum finalen, stabilen Entwicklungs-Workflow. Alle bisherigen Startprobleme sind durch diese radikale Vereinfachung gelöst.\n\n## 1. Der professionelle Startprozess (ohne .bat-Dateien)\n\nDer gesamte Setup-Prozess wurde auf den Standard der professionellen Web-Entwicklung umgestellt.\n\n**Schritt 1: Installieren**\nÖffne ein Terminal (z.B. \"Eingabeaufforderung\") im Projektordner und führe einmalig aus:\n```bash\nnpm install\n```\n\n**Schritt 2: Starten**\nFühre danach im selben Terminal aus:\n```bash\nnpm run dev\n```\n\nEin Browser-Tab sollte sich automatisch mit der laufenden Anwendung öffnen.\n\n## 2. Dein täglicher Workflow\n\n1.  **Starten:** Öffne ein Terminal und führe `npm run dev` aus.\n2.  **Arbeiten:** Nimm alle deine Code-Änderungen im `src`-Verzeichnis vor.\n3.  **Testen:** Speichere deine Änderungen. Vite aktualisiert die Anwendung im Browser sofort und automatisch.\n\n## 3. WICHTIG: Projekt-Bereinigung\n\nUm Fehler wie den `main.py` Fehler endgültig zu beseitigen, **lösche bitte alle `.bat`-Dateien** aus deinem Projektordner. Der Start erfolgt NUR noch über die Kommandozeile wie oben beschrieben."
    },
    {
      "path": "beta/index.html",
      "content": ""
    },
    {
      "path": "package.json",
      "content": "\n\n{\n  \"name\": \"scriptdax-os\",\n  \"version\": \"5.1.0\",\n  \"description\": \"An interactive, quest-driven simulation of a software development lifecycle, ready for deployment.\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\",\n    \"preview\": \"vite preview\",\n    \"test\": \"vitest\"\n  },\n  \"dependencies\": {\n    \"@google/genai\": \"^1.12.0\",\n    \"jszip\": \"^3.10.1\"\n  },\n  \"devDependencies\": {\n    \"@preact/preset-vite\": \"^2.9.0\",\n    \"@testing-library/preact\": \"^3.2.4\",\n    \"jsdom\": \"^24.1.0\",\n    \"vite\": \"^5.3.4\",\n    \"vitest\": \"^1.6.0\"\n  }\n}"
    },
    {
      "path": "build.js",
      "content": ""
    },
    {
      "path": "watch.js",
      "content": ""
    },
    {
      "path": "src/store/helpers.js",
      "content": "\nexport const getFromStorage = (key, defaultValue) => {\n    try {\n        const item = localStorage.getItem(key);\n        return item ? JSON.parse(item) : defaultValue;\n    } catch (error) {\n        console.error(`Error reading from localStorage for key “${key}”:`, error);\n        return defaultValue;\n    }\n};\n\nexport const saveToStorage = (key, value) => {\n    try {\n        localStorage.setItem(key, JSON.stringify(value));\n    } catch (error) {\n        console.error(`Error writing to localStorage for key “${key}”:`, error);\n    }\n};\n\nexport const downloadFile = (content, fileName, contentType) => {\n    const a = document.createElement(\"a\");\n    const file = new Blob([content], { type: contentType });\n    a.href = URL.createObjectURL(file);\n    a.download = fileName;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(a.href);\n};"
    },
    {
      "path": "src/store/initialState.js",
      "content": "\nexport const DEV_SUFFIX = '.dev666';\nexport const BETA_SUFFIX = '.beta666';\n\nexport const defaultStats = {\n    name: 'Operator',\n    displayName: 'Operator',\n    level: 1,\n    xp: 0,\n    reputation: {\n        \"Stellar Federation\": 50,\n        \"Mars Conglomerate\": 50,\n        \"Jupiter Collective\": 50,\n    },\n    morality: 50,\n    credits: 1000,\n    successStreak: 0,\n    failureStreak: 0,\n    mindsetState: 'neutral', // 'neutral', 'focused', 'frustrated'\n};\n\nexport const defaultSettings = {\n    musicVolume: 50,\n    sfxVolume: 75,\n    voiceVolume: 80,\n    useLocalFallback: false, // Sparfuchs Feature: Default to live API\n};\n\nexport const XP_FOR_NEXT_LEVEL = (level) => Math.floor(100 * Math.pow(level, 1.5));\nexport const REP_THRESHOLD_FRIENDLY = 75;\nexport const REP_THRESHOLD_HOSTILE = 25;\nexport const QUEST_LOG_CAPACITY = 5; // Sparfuchs Feature: Limit active quests"
    },
    {
      "path": "vitest.config.js",
      "content": ""
    },
    {
      "path": "gitignore.txt",
      "content": ""
    },
    {
      "path": "src/components/DebugPanel.js",
      "content": "\nimport { h } from 'preact';\nimport { useState } from 'preact/hooks';\nimport { useStore } from '../store/AppContext.js';\nimport { Icon } from './Icon.js';\nimport { DebugConsole } from './DebugConsole.js';\n\nexport const DebugPanel = () => {\n    const { activeProfile, actions, reports, newReportsCount, isDebugConsoleOpen, unverifiedFixLogsCount, settings } = useStore();\n    const [isCollapsed, setIsCollapsed] = useState(true);\n\n    if (!activeProfile || (!activeProfile.isDeveloper && !activeProfile.isBetaTester)) {\n        return null;\n    }\n\n    const { isDeveloper } = activeProfile;\n    const panelType = isDeveloper ? 'dev' : 'beta';\n\n    const handleToggle = () => setIsCollapsed(!isCollapsed);\n    \n    const handleSparmodusToggle = () => {\n        actions.setSettings({ ...settings, useLocalFallback: !settings.useLocalFallback });\n    };\n    \n    const createHostileMarsProfile = () => {\n        actions.createSyntheticProfile({\n            name: 'HostileMarsOp.dev666',\n            stats: { \n                level: 5,\n                reputation: {\n                    \"Stellar Federation\": 80,\n                    \"Mars Conglomerate\": 5,\n                    \"Jupiter Collective\": 60,\n                }\n            }\n        });\n    };\n    \n    const createHighLevelProfile = () => {\n        actions.createSyntheticProfile({\n            name: 'VeteranOp.dev666',\n            stats: { \n                level: 20,\n                credits: 50000,\n                morality: 85,\n            }\n        });\n    };\n\n    return h('div', { className: `debug-panel-container ${panelType} ${isCollapsed ? 'collapsed' : ''}` },\n        isDebugConsoleOpen && h(DebugConsole),\n        h('div', { className: 'debug-panel-header', onClick: handleToggle },\n            h(Icon, { name: isDeveloper ? 'devops' : 'science', size: 20 }),\n            h('h3', null, isDeveloper ? 'DevTools' : 'Beta Test Panel'),\n            h(Icon, { name: isCollapsed ? 'xp' : 'chart', size: 24, className: 'toggle-icon' })\n        ),\n        !isCollapsed && h('div', { className: 'debug-panel-content' },\n            h('div', { className: 'debug-section' },\n                h('h4', {className: 'debug-section-title' }, 'Beta Test Actions'),\n                h('button', { className: `button secondary ${isDeveloper ? '' : 'beta-style'} full-width`, onClick: actions.openReportModal }, 'Problem / Idee melden'),\n            ),\n            \n            isDeveloper && h(h, null,\n                h('div', { className: 'debug-section' },\n                     h('h4', {className: 'debug-section-title' }, 'Synthetische Operatoren'),\n                     h('button', { className: 'button secondary', onClick: createHostileMarsProfile, title: 'Erstellt ein Lvl 5 Profil mit feindseliger Reputation beim Mars-Konglomerat.' }, 'Feindseliger Mars-Op'),\n                     h('button', { className: 'button secondary', onClick: createHighLevelProfile, title: 'Erstellt ein Lvl 20 Profil mit hohem Ansehen und Credits.' }, 'Lvl 20 Veteran'),\n                ),\n                h('div', { className: 'debug-section' },\n                     h('h4', {className: 'debug-section-title' }, 'Aktiver Operator'),\n                     h('button', { className: 'button', onClick: actions.addDebugCredits }, '+5k Credits'),\n                     h('button', { className: 'button', onClick: actions.addDebugXp }, '+250 XP'),\n                     h('button', { className: 'button secondary danger', onClick: actions.resetQuests }, 'Reset Quests'),\n                ),\n                h('div', { className: 'debug-section' },\n                    h('h4', {className: 'debug-section-title' }, 'System & QA'),\n                    h('button', { className: 'button secondary', onClick: () => actions.setGameState('report-viewer'), disabled: reports.length === 0 }, `Reports (${newReportsCount} neu)`),\n                    h('button', { className: 'button secondary', onClick: () => actions.setGameState('fix-verification') }, `Fixes (${unverifiedFixLogsCount})`),\n                    h('button', { className: 'button secondary', onClick: () => actions.setGameState('system-check') }, 'System Check'),\n                    h('button', { className: 'button secondary', onClick: actions.generateBetaLicenseKey }, 'Beta-Schlüssel'),\n                    h('button', { className: 'button secondary full-width', onClick: actions.exportReports, disabled: newReportsCount === 0 }, `Neue Reports exportieren`),\n                    h('button', { className: 'button secondary full-width', onClick: actions.logAiFixAndArchiveReports, disabled: newReportsCount === 0 }, 'Simuliere KI-Fix & Archivierung'),\n                    h('button', { className: 'button secondary full-width', onClick: actions.generateAndDisplayAiReport }, 'KI-Statusbericht erstellen'),\n                ),\n            ),\n\n            h('div', { className: 'debug-panel-divider' }),\n\n            h('div', { className: 'debug-panel-checkbox-item', onClick: actions.toggleDebugConsole },\n                h('input', { type: 'checkbox', id: 'toggle-console', checked: isDebugConsoleOpen, readOnly: true }),\n                h('label', { for: 'toggle-console' }, 'Debug-Konsole anzeigen')\n            ),\n             h('div', { className: 'debug-panel-checkbox-item', onClick: handleSparmodusToggle, title: 'Verwendet lokale Quest-Daten anstelle der API, um Kosten zu sparen.' },\n                h('input', { type: 'checkbox', id: 'toggle-fallback', checked: settings.useLocalFallback, readOnly: true }),\n                h('label', { for: 'toggle-fallback' }, 'Sparmodus (Lokaler Fallback)')\n            )\n        )\n    );\n};"
    },
    {
      "path": "src/components/ReportModal.js",
      "content": "\n\n\nimport { h } from 'preact';\nimport { useState } from 'preact/hooks';\nimport { useStore } from '../store/AppContext.js';\n\nconst reportCategories = [\n    \"Fehler\",\n    \"Idee\",\n    \"Unerwartetes Verhalten\",\n    \"Neues Feature\",\n];\n\nexport const ReportModal = () => {\n    const { actions } = useStore();\n    const [category, setCategory] = useState(reportCategories[0]);\n    const [description, setDescription] = useState('');\n\n    const handleSubmit = (e) => {\n        e.preventDefault();\n        if (description.trim()) {\n            actions.submitReport({ category, description: description.trim() });\n        }\n    };\n\n    return h('div', { className: 'report-modal-overlay' },\n        h('form', { className: 'report-modal-container', onSubmit: handleSubmit },\n            h('h2', { className: 'report-modal-title' }, 'Problem oder Idee melden'),\n            h('div', { className: 'creator-input-group' },\n                h('label', { className: 'creator-label', for: 'report-category' }, 'Kategorie'),\n                h('select', {\n                    id: 'report-category',\n                    className: 'creator-select',\n                    value: category,\n                    onChange: (e) => setCategory(e.target.value)\n                },\n                    reportCategories.map(cat => h('option', { key: cat, value: cat }, cat))\n                )\n            ),\n            h('div', { className: 'creator-input-group' },\n                h('label', { className: 'creator-label', for: 'report-description' }, 'Beschreibung'),\n                h('textarea', {\n                    id: 'report-description',\n                    className: 'creator-textarea',\n                    value: description,\n                    onInput: (e) => setDescription(e.target.value),\n                    placeholder: 'Bitte beschreiben Sie das Problem oder Ihre Idee so detailliert wie möglich...',\n                    rows: 6,\n                    required: true,\n                })\n            ),\n            h('div', { className: 'report-modal-actions' },\n                h('button', {\n                    type: 'button',\n                    className: 'button secondary',\n                    onClick: actions.closeReportModal,\n                }, 'Abbrechen'),\n                h('button', {\n                    type: 'submit',\n                    className: 'button',\n                    disabled: !description.trim(),\n                }, 'Report senden')\n            )\n        )\n    );\n};"
    },
    {
      "path": "src/components/ReportViewer.js",
      "content": "\n\nimport { h } from 'preact';\nimport { useStore } from '../store/AppContext.js';\nimport { ReportCard } from './ReportCard.js';\n\nexport const ReportViewer = () => {\n    const { reports, newReportsCount, actions } = useStore();\n\n    const sortedReports = [...reports].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));\n\n    return h('div', { className: 'report-viewer-container' },\n        h('h1', { className: 'report-viewer-title' }, 'Gespeicherte Reports'),\n        h('div', { className: 'report-viewer-list' },\n            sortedReports.length > 0 ? (\n                sortedReports.map(report => h(ReportCard, { key: report.id, report }))\n            ) : (\n                h('p', { className: 'no-profiles-message' }, 'Keine Reports in der lokalen Datenbank gefunden.')\n            )\n        ),\n        h('div', { className: 'report-viewer-footer' },\n             h('p', null, `${reports.length} Report(s) insgesamt (${newReportsCount} neu).`),\n            h('div', { className: 'report-viewer-footer-actions'},\n                h('button', {\n                    className: 'button secondary',\n                    onClick: actions.exportReports,\n                    disabled: newReportsCount === 0,\n                }, `Neue (${newReportsCount}) exportieren`),\n                h('button', {\n                    className: 'button secondary',\n                    onClick: () => actions.setGameState('main-menu'),\n                }, 'Zurück zum Hauptmenü')\n            )\n        )\n    );\n};"
    },
    {
      "path": "src/services/audioService.js",
      "content": "\n\n// src/services/audioService.js\nclass AudioService {\n    constructor() {\n        this.sfxVolume = 0.75;\n        this.musicVolume = 0.5;\n        this.isInitialized = false;\n        \n        this.sounds = {};\n        this.musicTracks = [];\n        this.currentTrackIndex = 0;\n        this.isMusicPlaying = false;\n\n        this.soundFiles = {\n            click: './assets/audio/ui_click.mp3',\n            success: './assets/audio/quest_success.mp3',\n            fail: './assets/audio/quest_fail.mp3',\n            levelUp: './assets/audio/level_up.mp3',\n        };\n\n        this.musicFiles = [\n            './assets/audio/background_musik_1.mp3',\n            './assets/audio/background_musik_2.mp3'\n        ];\n    }\n\n    async init(onProgress) {\n        if (this.isInitialized) return;\n\n        const allFileEntries = [\n            ...Object.entries(this.soundFiles),\n            ...this.musicFiles.map(file => ['music_track', file]) // Use a special key\n        ];\n\n        const totalFiles = allFileEntries.length;\n        let loadedFiles = 0;\n\n        const loadPromises = allFileEntries.map(([key, src]) => {\n            return new Promise((resolve) => {\n                const audio = new Audio(src);\n                \n                audio.oncanplaythrough = () => {\n                    loadedFiles++;\n                    if (onProgress) onProgress(loadedFiles, totalFiles);\n\n                    if (key === 'music_track') {\n                        this.musicTracks.push(audio);\n                    } else {\n                        this.sounds[key] = audio;\n                    }\n                    resolve();\n                };\n\n                audio.onerror = (e) => {\n                    console.error(`Failed to load audio: ${src}`, e);\n                    loadedFiles++;\n                    if (onProgress) onProgress(loadedFiles, totalFiles);\n                    resolve(); // Resolve anyway to not block the app\n                };\n            });\n        });\n\n        await Promise.all(loadPromises);\n        \n        this.musicTracks.forEach((track) => {\n            track.onended = () => {\n                if (this.isMusicPlaying && this.musicTracks.length > 0) {\n                    this.currentTrackIndex = (this.currentTrackIndex + 1) % this.musicTracks.length;\n                    this.musicTracks[this.currentTrackIndex].play().catch(e => console.warn('Autoplay for next track might be blocked.', e));\n                }\n            };\n        });\n\n        this.setSfxVolume(this.sfxVolume * 100);\n        this.setMusicVolume(this.musicVolume * 100);\n\n        this.isInitialized = true;\n    }\n\n    playSound(name) {\n        if (!this.isInitialized || !this.sounds[name]) {\n            console.warn(`Sound not found or service not initialized: ${name}`);\n            return;\n        }\n        \n        // Use a new Audio object for sound effects to allow overlapping sounds\n        const sound = new Audio(this.sounds[name].src);\n        sound.volume = this.sfxVolume;\n        sound.play().catch(e => console.error(`Error playing sound \"${name}\":`, e));\n    }\n    \n    playClickSound() {\n        this.playSound('click');\n    }\n    \n    playMusic() {\n        if (!this.isInitialized || this.musicTracks.length === 0 || this.isMusicPlaying) return;\n        \n        this.isMusicPlaying = true;\n        const currentTrack = this.musicTracks[this.currentTrackIndex];\n        currentTrack.play().catch(e => {\n            console.warn('Music autoplay was blocked by the browser. Will attempt to play on next user interaction.', e);\n            this.isMusicPlaying = false; // Reset to allow retry\n        });\n    }\n\n    stopMusic() {\n        if (!this.isInitialized) return;\n\n        this.isMusicPlaying = false;\n        this.musicTracks.forEach(track => {\n            track.pause();\n            track.currentTime = 0;\n        });\n        this.currentTrackIndex = 0;\n    }\n\n    setSfxVolume(volume) { // volume is 0-100\n        this.sfxVolume = volume / 100;\n    }\n\n    setMusicVolume(volume) { // volume is 0-100\n        this.musicVolume = volume / 100;\n        if (this.musicTracks) {\n            this.musicTracks.forEach(track => track.volume = this.musicVolume);\n        }\n    }\n}\n\nexport const audioService = new AudioService();"
    },
    {
      "path": "src/components/LoadingScreen.js",
      "content": "\n\n\nimport { h } from 'preact';\nimport { useStore } from '../store/AppContext.js';\n\nexport const LoadingScreen = () => {\n    const { loadingProgress, loadingMessage } = useStore();\n\n    return h('div', { className: 'loading-screen-container' },\n        h('h1', { className: 'loading-screen-title' }, 'ScriptDaX OS'),\n        h('div', { className: 'loading-progress-wrapper' },\n            h('div', { className: 'loading-progress-bar', style: { width: `${loadingProgress}%` } }),\n            h('span', { className: 'loading-progress-text' }, `${loadingProgress}%`)\n        ),\n        h('p', { className: 'loading-message' }, loadingMessage)\n    );\n};"
    },
    {
      "path": "src/components/Inventory.js",
      "content": "\n\nimport { h } from 'preact';\nimport { useState } from 'preact/hooks';\nimport { useStore } from '../store/AppContext.js';\nimport { Icon } from './Icon.js';\nimport { ItemTooltip } from './ItemTooltip.js';\n\nexport const Inventory = () => {\n    const { inventory } = useStore();\n    const [tooltip, setTooltip] = useState(null); // { item, x, y }\n\n    const handleItemClick = (e, item) => {\n        e.stopPropagation();\n        setTooltip({\n            item: item,\n            position: { x: e.clientX, y: e.clientY }\n        });\n    };\n\n    const handleMouseLeave = () => {\n        setTooltip(null);\n    };\n\n    return h('div', { className: 'inventory-panel', onMouseLeave: handleMouseLeave },\n        h('h3', { className: 'inventory-title' },\n            h(Icon, { name: 'inventory', size: 16 }),\n            'Inventar'\n        ),\n        h('div', { className: 'inventory-list' },\n            inventory.length > 0 ? (\n                inventory.map(item =>\n                    h('div', { \n                        key: item.id, \n                        className: 'inventory-item', \n                        onClick: (e) => handleItemClick(e, item),\n                    },\n                        h(Icon, { name: item.icon || 'inventory', size: 24 }),\n                        h('span', { className: 'inventory-item-name' }, item.name)\n                    )\n                )\n            ) : (\n                h('p', { className: 'inventory-empty' }, 'Inventar ist leer.')\n            )\n        ),\n        tooltip && h(ItemTooltip, { item: tooltip.item, position: tooltip.position })\n    );\n};"
    },
    {
      "path": "src/store/reducer.js",
      "content": "\nimport { persistenceService } from '../services/persistenceService.js';\nimport * as initial from './initialState.js';\nimport { techTree } from '../config/tech_tree.js';\n\n// --- Reducer Logic Helpers ---\n\nconst PACING_THRESHOLD_EAGER_MS = 4000;\n\nfunction updateLastActionTimestamp(state, timestamp) {\n    if (!state.lastActionTimestamp) {\n        return { ...state, lastActionTimestamp: timestamp, eagernessStreak: 0 };\n    }\n    const timeSinceLast = timestamp - state.lastActionTimestamp;\n    const newEagernessStreak = timeSinceLast < PACING_THRESHOLD_EAGER_MS ? (state.eagernessStreak || 0) + 1 : 0;\n    return {\n        ...state,\n        lastActionTimestamp: timestamp,\n        eagernessStreak: newEagernessStreak,\n    };\n}\n\nfunction applyXp(profile, xpAmount) {\n    if (!profile) return null;\n    let newStats = { ...profile.characterStats };\n\n    let finalXpAmount = xpAmount;\n    const researchedTechs = profile.researchedTechs || [];\n    \n    // Global boost from Singularity Core\n    if (researchedTechs.includes('singularity_core')) {\n        finalXpAmount = Math.floor(finalXpAmount * 1.25);\n    }\n    \n    // Check for active XP boost item\n    const activeXpBonusItem = (profile.activeBonuses || []).find(b => b.type === 'xp_boost');\n    if (activeXpBonusItem) {\n        finalXpAmount = Math.floor(finalXpAmount * activeXpBonusItem.multiplier);\n        profile.activeBonuses = profile.activeBonuses.filter(b => b.type !== 'xp_boost');\n    }\n\n    // Check for permanent XP boost from researched tech\n    const researchedXpBonus = researchedTechs\n        .map(techId => techTree.find(t => t.id === techId))\n        .filter(tech => tech && tech.bonus.type === 'XP_GAIN')\n        .reduce((total, tech) => total + tech.bonus.value, 0);\n\n    if (researchedXpBonus > 0) {\n        finalXpAmount = Math.floor(finalXpAmount * (1 + researchedXpBonus));\n    }\n\n\n    let newXp = newStats.xp + finalXpAmount;\n    let xpToNext = initial.XP_FOR_NEXT_LEVEL(newStats.level);\n    while (newXp >= xpToNext) {\n        newStats.level += 1;\n        newXp -= xpToNext;\n        xpToNext = initial.XP_FOR_NEXT_LEVEL(newStats.level);\n    }\n    newStats.xp = newXp;\n    \n    return { ...profile, characterStats: newStats };\n}\n\n\nfunction resolveQuestReducer(state, action) {\n    const { quest, chosenOutcome } = action.payload;\n    let profileToUpdate = state.rawProfiles.find(p => p.id === state.activeProfileId);\n    if (!profileToUpdate) return state;\n\n    let newStats = { ...profileToUpdate.characterStats };\n    const rewards = chosenOutcome.rewards;\n    const isSuccess = chosenOutcome.status !== 'failure';\n\n    // Check for global boost from Singularity Core for credits\n    const hasGlobalBoost = (profileToUpdate.researchedTechs || []).includes('singularity_core');\n    const creditMultiplier = hasGlobalBoost ? 1.25 : 1;\n\n    // --- Mindset Analyst: Streaks ---\n    if (isSuccess) {\n        newStats.successStreak = (newStats.successStreak || 0) + 1;\n        newStats.failureStreak = 0;\n    } else {\n        newStats.failureStreak = (newStats.failureStreak || 0) + 1;\n        newStats.successStreak = 0;\n    }\n\n    // --- Apply Rewards ---\n    newStats.credits += Math.floor(rewards.credits * creditMultiplier);\n    newStats.morality = Math.max(0, Math.min(100, newStats.morality + rewards.morality));\n    \n    const newRep = { ...newStats.reputation };\n    const { faction, change } = rewards.reputation;\n    newRep[faction] = Math.max(0, Math.min(100, (newRep[faction] || 50) + change));\n    newStats.reputation = newRep;\n    \n    profileToUpdate.characterStats = newStats;\n    profileToUpdate = applyXp(profileToUpdate, rewards.xp || 0);\n    if (!profileToUpdate) return state; // Should not happen\n    \n    const remainingQuests = profileToUpdate.quests.filter(q => q.id !== quest.id);\n    \n    let updatedInventory = [...(profileToUpdate.inventory || [])];\n    if (rewards.item) {\n        updatedInventory.push(rewards.item);\n    }\n    if (chosenOutcome.itemRequirement?.consumeOnUse) {\n        const itemIndex = updatedInventory.findIndex(item => item.name === chosenOutcome.itemRequirement.itemName);\n        if (itemIndex > -1) {\n            updatedInventory.splice(itemIndex, 1);\n        }\n    }\n    \n    const updatedProfile = {\n        ...profileToUpdate,\n        quests: remainingQuests,\n        completedQuests: isSuccess ? [...(profileToUpdate.completedQuests || []), quest] : (profileToUpdate.completedQuests || []),\n        failedQuests: !isSuccess ? [...(profileToUpdate.failedQuests || []), quest] : (profileToUpdate.failedQuests || []),\n        inventory: updatedInventory,\n        completedQuestHistory: [...(profileToUpdate.completedQuestHistory || []), quest.title].slice(-5), // Keep last 5 titles for context\n    };\n    \n    const newRawProfiles = state.rawProfiles.map(p => p.id === state.activeProfileId ? updatedProfile : p);\n    const newStateWithProfile = { ...state, rawProfiles: newRawProfiles, profiles: newRawProfiles.map(parseProfile).filter(Boolean) };\n    const stateWithTimestamp = updateLastActionTimestamp(newStateWithProfile, action.payload.timestamp);\n    return updateStateForActiveProfile(stateWithTimestamp);\n}\n\nfunction createProfileReducer(state, action) {\n    const { name, origin, learningGoal, id } = action.payload;\n    const newStats = { \n        ...initial.defaultStats, \n        name,\n    };\n    newStats.credits += origin.modifiers.credits;\n    newStats.morality = Math.max(0, Math.min(100, newStats.morality + origin.modifiers.morality));\n    Object.keys(origin.modifiers.reputation).forEach(faction => {\n        newStats.reputation[faction] = Math.max(0, Math.min(100, newStats.reputation[faction] || 50) + origin.modifiers.reputation[faction]));\n    });\n    const newProfile = {\n        id, characterStats: newStats, originId: origin.id, quests: [], completedQuests: [], failedQuests: [], inventory: [], discoveredNPCs: [], learningGoal, lastPlayed: new Date().toISOString(), completedQuestHistory: [], activeTheme: 'default', unlockedThemes: ['default'], researchedTechs: [],\n    };\n    const newRawProfiles = [...state.rawProfiles, newProfile];\n    const newState = { ...state, rawProfiles: newRawProfiles, profiles: newRawProfiles.map(parseProfile).filter(Boolean), activeProfileId: id, pendingBetaCreation: null, betaKeyError: null, gameState: 'game', isMusicActive: true };\n    return updateStateForActiveProfile(newState);\n}\n\nfunction generateQuestsSuccessReducer(state, action) {\n    const { quests, profileId, timestamp, analysis } = action.payload;\n    const newRawProfiles = state.rawProfiles.map(p => {\n        if (p.id === profileId) {\n            const existingNpcNames = new Set((p.discoveredNPCs || []).map(npc => npc.name));\n            const newNpcs = quests\n                .map(q => ({ name: q.npcName, faction: q.faction }))\n                .filter(npc => !existingNpcNames.has(npc.name));\n            // Prio 3: Reset mindsetState after new quests are generated\n            const newStats = { ...p.characterStats, mindsetState: 'neutral' };\n            return { ...p, quests: [...(p.quests || []), ...quests], discoveredNPCs: [...(p.discoveredNPCs || []), ...newNpcs], characterStats: newStats };\n        }\n        return p;\n    });\n    const newState = { ...state, isLoading: false, rawProfiles: newRawProfiles, profiles: newRawProfiles.map(parseProfile).filter(Boolean), costBenefitAnalysis: analysis };\n    const stateWithTimestamp = updateLastActionTimestamp(newState, timestamp);\n    return updateStateForActiveProfile(stateWithTimestamp);\n}\n\n// --- Initial State and Profile Parsing ---\n\nconst parseProfile = (p) => {\n    if (!p || !p.characterStats || typeof p.characterStats.name !== 'string') {\n        console.warn('Ein beschädigtes oder veraltetes Profil wurde übersprungen.', p);\n        return null;\n    }\n    const rawName = p.characterStats.name;\n    const isDeveloper = rawName.endsWith(initial.DEV_SUFFIX);\n    const isBetaTester = rawName.endsWith(initial.BETA_SUFFIX);\n    const displayName = isDeveloper ? rawName.slice(0, -initial.DEV_SUFFIX.length) : (isBetaTester ? rawName.slice(0, -initial.BETA_SUFFIX.length) : rawName);\n\n    const mergedStats = {\n        ...initial.defaultStats,\n        ...p.characterStats,\n        displayName,\n    };\n\n    return { ...p, isDeveloper, isBetaTester, characterStats: mergedStats, activeTheme: p.activeTheme || 'default', unlockedThemes: p.unlockedThemes || ['default'], researchedTechs: p.researchedTechs || [] };\n};\n\nconst getInitialState = () => {\n    const emptyState = {\n        gameState: 'loading',\n        isLoading: false,\n        error: null,\n        loadingProgress: 0,\n        loadingMessage: 'System wird hochgefahren...',\n        settings: initial.defaultSettings,\n        rawProfiles: [],\n        profiles: [],\n        activeProfile: null,\n        activeProfileId: null,\n        characterStats: initial.defaultStats,\n        quests: [],\n        inventory: [],\n        learningGoal: { keyword: '', description: '' },\n        completedQuests: [],\n        events: [],\n        notifications: [],\n        betaLicenseKeys: [],\n        pendingBetaCreation: null,\n        betaKeyError: null,\n        isReportModalOpen: false,\n        reports: [],\n        fixLogs: [],\n        isMusicActive: false,\n        isDebugConsoleOpen: false,\n        debugLogs: [],\n        marketAnalysis: { opinion: null, isLoading: false, error: null, applicationStrategies: {} },\n        lastActionTimestamp: null,\n        lastCoachInterventionTimestamp: null,\n        eagernessStreak: 0,\n        lastActionType: null,\n        projectActionCounter: 0,\n        linuxBuildStatus: 'idle',\n        linuxBuildFailureReason: null,\n        costBenefitAnalysis: null,\n        betaTeam: [],\n        betaTeamStatus: 'idle',\n        projectChronicle: { isLoading: false, error: null, content: null },\n    };\n\n    const loadedState = persistenceService.loadFullState(emptyState);\n    \n    // After loading, parse profiles and set the active one\n    const profiles = (loadedState.rawProfiles || []).map(parseProfile).filter(p => p !== null);\n    const activeProfile = profiles.find(p => p.id === loadedState.activeProfileId) || null;\n    \n    return { ...loadedState, profiles, activeProfile };\n};\n\nexport const initialState = getInitialState();\n\nfunction updateStateForActiveProfile(state) {\n    const activeProfile = state.profiles.find(p => p.id === state.activeProfileId);\n    if (activeProfile) {\n        return {\n            ...state,\n            activeProfile,\n            characterStats: activeProfile.characterStats,\n            quests: activeProfile.quests || [],\n            completedQuests: activeProfile.completedQuests || [],\n            inventory: activeProfile.inventory || [],\n            learningGoal: activeProfile.learningGoal,\n            betaTeam: activeProfile.betaTeam || [],\n            betaTeamStatus: activeProfile.betaTeamStatus || 'idle',\n        };\n    }\n    // If no active profile, reset session data\n    return {\n        ...state,\n        activeProfile: null,\n        characterStats: initial.defaultStats,\n        quests: [],\n        completedQuests: [],\n        inventory: [],\n        learningGoal: { keyword: '', description: '' },\n        betaTeam: [],\n        betaTeamStatus: 'idle',\n    };\n}\n\n\n// --- Main Reducer ---\n\nexport function appReducer(state, action) {\n    const stateWithActionType = { ...state, lastActionType: action.type };\n\n    switch (action.type) {\n        case 'APP_INITIALIZED':\n            return { ...stateWithActionType, gameState: 'landing-page' };\n\n        case 'SET_GAME_STATE':\n            return { ...stateWithActionType, gameState: action.payload };\n        case 'SET_LOADING_PROGRESS':\n            return { ...stateWithActionType, loadingProgress: action.payload.progress, loadingMessage: action.payload.message };\n        case 'SET_LOADING_MESSAGE':\n             return { ...stateWithActionType, loadingMessage: action.payload };\n        case 'SET_SETTINGS': {\n            const newSettings = { ...state.settings, ...action.payload };\n            return { ...stateWithActionType, settings: newSettings };\n        }\n        case 'SHOW_NOTIFICATION':\n            return { ...stateWithActionType, notifications: [...state.notifications, action.payload] };\n        case 'SET_NOTIFICATION_EXITING':\n            return {\n                ...stateWithActionType,\n                notifications: state.notifications.map(n => n.id === action.payload ? { ...n, exiting: true } : n)\n            };\n        case 'HIDE_NOTIFICATION':\n            return { ...stateWithActionType, notifications: state.notifications.filter(n => n.id !== action.payload) };\n\n        // --- API & Quest Lifecycle ---\n        case 'GENERATE_QUESTS_START':\n            return { ...stateWithActionType, isLoading: true, error: null, costBenefitAnalysis: null };\n        case 'API_ERROR':\n            return { ...stateWithActionType, isLoading: false, error: action.payload };\n        case 'GENERATE_QUESTS_SUCCESS':\n            return generateQuestsSuccessReducer(stateWithActionType, action);\n        case 'RESOLVE_QUEST':\n             const resolvedState = resolveQuestReducer(stateWithActionType, action);\n             const { successStreak, failureStreak } = resolvedState.characterStats;\n             let mindsetState = 'neutral';\n             if (successStreak >= 3) mindsetState = 'focused';\n             if (failureStreak >= 2) mindsetState = 'frustrated';\n             const profileWithMindset = {\n                ...resolvedState.activeProfile,\n                characterStats: { ...resolvedState.characterStats, mindsetState },\n             };\n             const updatedRawProfiles = resolvedState.rawProfiles.map(p => p.id === resolvedState.activeProfileId ? profileWithMindset : p);\n             const finalState = { ...resolvedState, rawProfiles: updatedRawProfiles, profiles: updatedRawProfiles.map(parseProfile).filter(Boolean) };\n             return updateStateForActiveProfile(finalState);\n\n        // --- Profile Management ---\n        case 'CREATE_PROFILE':\n            return createProfileReducer(stateWithActionType, action);\n        case 'LOAD_PROFILE': {\n            const newState = { ...stateWithActionType, activeProfileId: action.payload, gameState: 'game', isMusicActive: true };\n            return updateStateForActiveProfile(newState);\n        }\n        case 'LOAD_LAST_PROFILE': {\n            const newState = { ...stateWithActionType, gameState: 'game', isMusicActive: true };\n            return updateStateForActiveProfile(newState);\n        }\n        case 'DELETE_PROFILE': {\n            const newRawProfiles = state.rawProfiles.filter(p => p.id !== action.payload);\n            const newState = { ...stateWithActionType, rawProfiles: newRawProfiles, profiles: newRawProfiles.map(parseProfile).filter(Boolean) };\n            if (state.activeProfileId === action.payload) {\n                return updateStateForActiveProfile({ ...newState, activeProfileId: null });\n            }\n            return newState;\n        }\n        case 'DELETE_ACTIVE_PROFILE': {\n            const newRawProfiles = state.rawProfiles.filter(p => p.id !== state.activeProfileId);\n            const newState = { ...stateWithActionType, rawProfiles: newRawProfiles, profiles: newRawProfiles.map(parseProfile).filter(Boolean), activeProfileId: null, gameState: 'main-menu' };\n            return updateStateForActiveProfile(newState);\n        }\n        case 'IMPORT_PROFILES': {\n            const importedProfiles = action.payload;\n            const newProfilesMap = new Map(state.rawProfiles.map(p => [p.id, p]));\n            importedProfiles.forEach(p => newProfilesMap.set(p.id, p));\n            const newRawProfiles = Array.from(newProfilesMap.values());\n            const newState = { ...stateWithActionType, rawProfiles: newRawProfiles, profiles: newRawProfiles.map(parseProfile).filter(Boolean)};\n            return newState;\n        }\n        case 'RESTORE_STATE': {\n            const restoredData = action.payload;\n            return {\n                ...initialState,\n                rawProfiles: restoredData.rawProfiles || [],\n                profiles: (restoredData.rawProfiles || []).map(parseProfile).filter(Boolean),\n                settings: restoredData.settings || initial.defaultSettings,\n                betaLicenseKeys: restoredData.betaLicenseKeys || [],\n                reports: restoredData.reports || [],\n                fixLogs: restoredData.fixLogs || [],\n                activeProfileId: null, // Force user to re-select a profile after restore\n            };\n        }\n        \n        case 'TIMESTAMP_ACTION':\n             const stateWithTimestamp = updateLastActionTimestamp(stateWithActionType, action.payload.timestamp);\n             return { ...stateWithTimestamp, projectActionCounter: state.projectActionCounter + 1 };\n\n        // --- Beta Flow ---\n        case 'START_BETA_CREATION':\n            return { ...stateWithActionType, gameState: 'beta-key-entry', pendingBetaCreation: action.payload };\n        case 'CANCEL_BETA_CREATION':\n            return { ...stateWithActionType, gameState: 'character-creator', pendingBetaCreation: null, betaKeyError: null };\n        case 'SET_BETA_KEY_ERROR':\n            return { ...stateWithActionType, betaKeyError: action.payload };\n        case 'CONSUME_BETA_KEY':\n            return { ...stateWithActionType, betaLicenseKeys: state.betaLicenseKeys.filter(k => k !== action.payload) };\n        case 'ADD_BETA_KEY':\n            return { ...stateWithActionType, betaLicenseKeys: [...state.betaLicenseKeys, action.payload] };\n\n        // --- Reporting & QA ---\n        case 'SET_MODAL_STATE':\n            return { ...stateWithActionType, [`is${action.payload.modal.charAt(0).toUpperCase() + action.payload.modal.slice(1)}ModalOpen`]: action.payload.isOpen };\n        case 'SUBMIT_REPORT': {\n            let profileToUpdate = state.rawProfiles.find(p => p.id === state.activeProfileId);\n            if (!profileToUpdate) return stateWithActionType;\n\n            const newReport = {\n                id: self.crypto.randomUUID(),\n                timestamp: new Date().toISOString(),\n                ...action.payload,\n                profileName: state.activeProfile?.characterStats?.displayName || 'Unknown',\n                gameStateAtReport: state.gameState,\n                isArchived: false,\n            };\n            \n            // Add XP for submitting a report\n            let xpAmount = 10;\n            if (profileToUpdate.linuxBuild) xpAmount = Math.floor(xpAmount * 1.1);\n            profileToUpdate = applyXp(profileToUpdate, xpAmount);\n            \n            const newRawProfiles = state.rawProfiles.map(p => p.id === state.activeProfileId ? profileToUpdate : p);\n            const stateWithReport = { ...stateWithActionType, rawProfiles: newRawProfiles, reports: [...state.reports, newReport], isReportModalOpen: false };\n            const stateWithTimestampAndProfile = updateStateForActiveProfile(stateWithReport);\n            return updateLastActionTimestamp(stateWithTimestampAndProfile, action.payload.timestamp);\n        }\n        case 'ARCHIVE_REPORTS': {\n            const { ids, reopen } = action.payload;\n            return { ...stateWithActionType, reports: state.reports.map(r => ids.includes(r.id) ? { ...r, isArchived: !reopen, reopened_from_failed_fix: reopen } : r) };\n        }\n        case 'REOPEN_REPORTS': {\n            return { ...stateWithActionType, reports: state.reports.map(r => action.payload.includes(r.id) ? { ...r, isArchived: false, reopened_from_failed_fix: true } : r) };\n        }\n        case 'LOG_AI_FIX': {\n            const stateWithFix = { ...stateWithActionType, fixLogs: [...state.fixLogs, action.payload] };\n            return updateLastActionTimestamp(stateWithFix, action.payload.timestamp);\n        }\n        case 'UPDATE_FIX_LOG_QA': {\n            const { logId, grade, timestamp } = action.payload;\n            let profileToUpdate = state.rawProfiles.find(p => p.id === state.activeProfileId);\n            if (!profileToUpdate) return stateWithActionType;\n\n            // Add XP only for passing grades\n            if (grade >= 1 && grade <= 3) {\n                let xpAmount = 25;\n                \n                // Apply QA reward bonus from tech\n                const researchedQaBonus = (profileToUpdate.researchedTechs || [])\n                    .map(techId => techTree.find(t => t.id === techId))\n                    .filter(tech => tech && tech.bonus.type === 'QA_REWARD_BONUS')\n                    .reduce((total, tech) => total + tech.bonus.value, 0);\n\n                if (researchedQaBonus > 0) {\n                    xpAmount = Math.floor(xpAmount * (1 + researchedQaBonus));\n                }\n\n                if (profileToUpdate.linuxBuild) xpAmount = Math.floor(xpAmount * 1.1);\n                profileToUpdate = applyXp(profileToUpdate, xpAmount);\n            }\n            \n            const newRawProfiles = state.rawProfiles.map(p => p.id === state.activeProfileId ? profileToUpdate : p);\n\n            const stateWithQa = {\n                ...stateWithActionType,\n                rawProfiles: newRawProfiles,\n                fixLogs: state.fixLogs.map(log => log.id === logId ? { ...log, qaStatus: { grade, verifiedAt: new Date().toISOString() } } : log)\n            };\n            const stateWithTimestampAndProfile = updateStateForActiveProfile(stateWithQa);\n            return updateLastActionTimestamp(stateWithTimestampAndProfile, timestamp);\n        }\n        \n        // --- R&D Lab ---\n        case 'RESEARCH_TECHNOLOGY': {\n            const { techId } = action.payload;\n            const tech = techTree.find(t => t.id === techId);\n            let profile = state.rawProfiles.find(p => p.id === state.activeProfileId);\n            if (!tech || !profile || profile.researchedTechs.includes(techId)) {\n                return stateWithActionType; // Already researched or invalid\n            }\n\n            // Check requirements\n            const hasEnoughCredits = profile.characterStats.credits >= tech.cost.credits;\n            const hasRequiredLevel = profile.characterStats.level >= tech.cost.level;\n            const dependenciesMet = tech.dependencies.every(depId => profile.researchedTechs.includes(depId));\n\n            if (hasEnoughCredits && hasRequiredLevel && dependenciesMet) {\n                profile.characterStats.credits -= tech.cost.credits;\n                profile.researchedTechs.push(techId);\n                const newRawProfiles = state.rawProfiles.map(p => p.id === state.activeProfileId ? profile : p);\n                const newState = { ...stateWithActionType, rawProfiles: newRawProfiles };\n                return updateStateForActiveProfile(newState);\n            }\n            return stateWithActionType; // Requirements not met\n        }\n        \n        // --- Debug & Analyst Actions ---\n        case 'TOGGLE_DEBUG_CONSOLE':\n            return { ...stateWithActionType, isDebugConsoleOpen: !state.isDebugConsoleOpen };\n        case 'SET_DEBUG_CONSOLE_STATE':\n            return { ...stateWithActionType, isDebugConsoleOpen: action.payload };\n        case 'LOG_TO_DEBUG_CONSOLE': {\n            const newLogEntry = {\n                id: self.crypto.randomUUID(),\n                timestamp: new Date().toISOString(),\n                type: 'ai-report',\n                content: action.payload,\n            };\n            return { ...stateWithActionType, debugLogs: [...state.debugLogs, newLogEntry] };\n        }\n        case 'TRIGGER_TEAM_ANALYSIS': {\n            const { message, bonus } = action.payload;\n            const event = { id: self.crypto.randomUUID(), message, timestamp: new Date().toISOString() };\n            if (bonus && state.activeProfile) {\n                let updatedProfile = {\n                    ...state.activeProfile,\n                    activeBonuses: [...(state.activeProfile.activeBonuses || []), bonus]\n                };\n                const newRawProfiles = state.rawProfiles.map(p => p.id === state.activeProfileId ? updatedProfile : p);\n                const newState = { ...stateWithActionType, rawProfiles: newRawProfiles, profiles: newRawProfiles.map(parseProfile).filter(Boolean) };\n                 return { ...updateStateForActiveProfile(newState), events: [event, ...state.events] };\n            }\n            return { ...stateWithActionType, events: [event, ...state.events] };\n        }\n        case 'TRIGGER_MENTAL_COACH_INTERVENTION': {\n            const { message } = action.payload;\n            const event = { id: self.crypto.randomUUID(), message, timestamp: new Date().toISOString() };\n            const newState = { ...stateWithActionType, eagernessStreak: 0 }; // Reset streak after coach intervention\n            return { ...newState, events: [event, ...state.events], lastCoachInterventionTimestamp: Date.now() };\n        }\n         case 'TRIGGER_PROJECT_MANAGER_INTERVENTION': {\n            const event = { id: self.crypto.randomUUID(), message: action.payload.message, timestamp: new Date().toISOString() };\n            return { ...stateWithActionType, events: [event, ...state.events], projectActionCounter: 0 }; // Reset counter\n        }\n        case 'INJECT_BUG_REPORT': {\n            const newReport = { ...action.payload, profileName: 'Cerberus-QA' };\n            return { ...stateWithActionType, reports: [...state.reports, newReport] };\n        }\n        case 'CREATE_SYNTHETIC_PROFILE': {\n            const { name, stats } = action.payload;\n            const newStats = { ...initial.defaultStats, ...stats, name };\n            const newProfile = { id: self.crypto.randomUUID(), characterStats: newStats, originId: 'federation_graduate', quests: [], lastPlayed: new Date().toISOString(), unlockedThemes: ['default'], activeTheme: 'default', researchedTechs: [] };\n            const newRawProfiles = [...state.rawProfiles, newProfile];\n            return { ...stateWithActionType, rawProfiles: newRawProfiles, profiles: newRawProfiles.map(parseProfile).filter(Boolean)};\n        }\n        case 'ADD_DEBUG_CREDITS': {\n             const p = state.activeProfile;\n             if (!p) return stateWithActionType;\n             const newStats = { ...p.characterStats, credits: p.characterStats.credits + 5000 };\n             const updatedProfile = { ...p, characterStats: newStats };\n             const newRawProfiles = state.rawProfiles.map(prof => prof.id === p.id ? updatedProfile : prof);\n             return updateStateForActiveProfile({ ...stateWithActionType, rawProfiles: newRawProfiles, profiles: newRawProfiles.map(parseProfile).filter(Boolean) });\n        }\n        case 'ADD_DEBUG_XP': {\n            const p = state.activeProfile;\n            if (!p) return stateWithActionType;\n            const updatedProfile = applyXp(p, 250);\n            const newRawProfiles = state.rawProfiles.map(prof => prof.id === p.id ? updatedProfile : prof);\n            return updateStateForActiveProfile({ ...stateWithActionType, rawProfiles: newRawProfiles, profiles: newRawProfiles.map(parseProfile).filter(Boolean) });\n        }\n        case 'RESET_QUESTS': {\n             const p = state.activeProfile;\n             if (!p) return stateWithActionType;\n             const updatedProfile = { ...p, quests: [], completedQuests: [], failedQuests: [] };\n             const newRawProfiles = state.rawProfiles.map(prof => prof.id === p.id ? updatedProfile : prof);\n             return updateStateForActiveProfile({ ...stateWithActionType, rawProfiles: newRawProfiles, profiles: newRawProfiles.map(parseProfile).filter(Boolean) });\n        }\n        \n        // --- Market Analysis ---\n        case 'GET_BETA_OPINION_START':\n            return { ...stateWithActionType, marketAnalysis: { ...state.marketAnalysis, isLoading: true, error: null, opinion: null } };\n        case 'GET_BETA_OPINION_SUCCESS': {\n            const stateWithOpinion = { ...stateWithActionType, marketAnalysis: { ...state.marketAnalysis, isLoading: false, opinion: action.payload.opinion } };\n            return updateLastActionTimestamp(stateWithOpinion, action.payload.timestamp);\n        }\n        case 'GET_BETA_OPINION_ERROR':\n            return { ...stateWithActionType, marketAnalysis: { ...state.marketAnalysis, isLoading: false, error: action.payload } };\n\n        // --- Application Strategist ---\n        case 'GET_APP_STRATEGY_START': {\n            const { programId } = action.payload;\n            const newStrategies = { ...state.marketAnalysis.applicationStrategies, [programId]: { isLoading: true, error: null, strategy: null } };\n            return { ...stateWithActionType, marketAnalysis: { ...state.marketAnalysis, applicationStrategies: newStrategies } };\n        }\n        case 'GET_APP_STRATEGY_SUCCESS': {\n            const { programId, strategy, timestamp } = action.payload;\n            const newStrategies = { ...state.marketAnalysis.applicationStrategies, [programId]: { isLoading: false, error: null, strategy } };\n            const stateWithStrategy = { ...stateWithActionType, marketAnalysis: { ...state.marketAnalysis, applicationStrategies: newStrategies } };\n            return updateLastActionTimestamp(stateWithStrategy, timestamp);\n        }\n        case 'GET_APP_STRATEGY_ERROR': {\n            const { programId, error } = action.payload;\n            const newStrategies = { ...state.marketAnalysis.applicationStrategies, [programId]: { isLoading: false, error, strategy: null } };\n            return { ...stateWithActionType, marketAnalysis: { ...state.marketAnalysis, applicationStrategies: newStrategies } };\n        }\n        \n        // --- Linux Initiative ---\n        case 'SET_LINUX_BUILD_STATUS': {\n            const { status, reason } = action.payload;\n            return { ...stateWithActionType, linuxBuildStatus: status, linuxBuildFailureReason: reason || null };\n        }\n        case 'SET_LINUX_BUILD_SUCCESS': {\n             let profileToUpdate = state.rawProfiles.find(p => p.id === state.activeProfileId);\n             if (!profileToUpdate) return stateWithActionType;\n\n             profileToUpdate.linuxBuild = true;\n             // Unlock mars theme on linux build\n             if (!profileToUpdate.unlockedThemes.includes('mars')) {\n                 profileToUpdate.unlockedThemes.push('mars');\n             }\n             \n            const newRawProfiles = state.rawProfiles.map(p => p.id === state.activeProfileId ? profileToUpdate : p);\n            const newState = { \n                ...stateWithActionType, \n                rawProfiles: newRawProfiles, \n                profiles: newRawProfiles.map(parseProfile).filter(Boolean),\n                linuxBuildStatus: 'success' \n            };\n            return updateStateForActiveProfile(newState);\n        }\n\n        // --- Beta Team Management ---\n        case 'RECRUIT_BETA_TEAM_START': {\n             const newRawProfiles = state.rawProfiles.map(p => \n                p.id === state.activeProfileId ? { ...p, betaTeamStatus: 'recruiting' } : p\n            );\n             const newState = { ...stateWithActionType, rawProfiles: newRawProfiles };\n             return updateStateForActiveProfile(newState);\n        }\n        case 'RECRUIT_BETA_TEAM_SUCCESS': {\n            const { team } = action.payload;\n            let profileToUpdate = state.rawProfiles.find(p => p.id === state.activeProfileId);\n            if (!profileToUpdate) return stateWithActionType;\n            \n            profileToUpdate.betaTeam = team;\n            profileToUpdate.betaTeamStatus = 'active';\n            // Unlock jupiter theme on team recruitment\n            if (!profileToUpdate.unlockedThemes.includes('jupiter')) {\n                 profileToUpdate.unlockedThemes.push('jupiter');\n             }\n\n            const newRawProfiles = state.rawProfiles.map(p => p.id === state.activeProfileId ? profileToUpdate : p);\n            const newState = { ...stateWithActionType, rawProfiles: newRawProfiles };\n            return updateStateForActiveProfile(newState);\n        }\n\n        // --- UX Refinement ---\n        case 'SET_THEME': {\n             let profileToUpdate = state.rawProfiles.find(p => p.id === state.activeProfileId);\n             if (!profileToUpdate || !profileToUpdate.unlockedThemes.includes(action.payload)) return stateWithActionType;\n             \n             profileToUpdate.activeTheme = action.payload;\n\n             const newRawProfiles = state.rawProfiles.map(p => p.id === state.activeProfileId ? profileToUpdate : p);\n             const newState = { ...stateWithActionType, rawProfiles: newRawProfiles };\n             return updateStateForActiveProfile(newState);\n        }\n        \n        // --- Project Chronicle ---\n        case 'GENERATE_BIOGRAPHY_START':\n            return { ...stateWithActionType, projectChronicle: { isLoading: true, error: null, content: null } };\n        case 'GENERATE_BIOGRAPHY_SUCCESS':\n            return { ...stateWithActionType, projectChronicle: { isLoading: false, error: null, content: action.payload } };\n        case 'GENERATE_BIOGRAPHY_ERROR':\n            return { ...stateWithActionType, projectChronicle: { isLoading: false, error: action.payload, content: null } };\n\n        default:\n            return stateWithActionType;\n    }\n}"
    },
    {
      "path": "src/components/Notifications.js",
      "content": "\n\n\nimport { h } from 'preact';\nimport { createPortal } from 'preact/compat';\nimport { useStore } from '../store/AppContext.js';\nimport { Icon } from './Icon.js';\n\nexport const Notifications = () => {\n    const { notifications, actions } = useStore();\n    \n    // We need a portal because the notifications container is outside the main #root\n    const container = document.getElementById('notifications-container');\n    if (!container) {\n        // This might happen on the very first render cycle.\n        // It's safe to return null, it will re-render once the DOM is ready.\n        return null;\n    }\n\n    return createPortal(\n        notifications.map(note => (\n            h('div', { \n                key: note.id,\n                className: `notification ${note.type} ${note.exiting ? 'exiting' : ''}`,\n                onAnimationEnd: (e) => {\n                    // When the exit animation completes, dispatch an action to remove it from state.\n                    if (e.animationName === 'slideOutRight') {\n                        actions.hideNotification(note.id);\n                    }\n                }\n            },\n                h(Icon, { name: note.icon, size: 24 }),\n                h('p', { dangerouslySetInnerHTML: { __html: note.message } })\n            )\n        )),\n        container\n    );\n};"
    },
    {
      "path": "src/components/DebugConsole.js",
      "content": "\n\n\nimport { h } from 'preact';\nimport { useStore } from '../store/AppContext.js';\nimport { useMemo } from 'preact/hooks';\n\nexport const DebugConsole = () => {\n    const { actions, debugLogs, events } = useStore();\n\n    // Combine and sort logs and events\n    const combinedLogs = useMemo(() => {\n        const allItems = [\n            ...debugLogs.map(log => ({ ...log, isLog: true })),\n            ...events.map(event => ({ ...event, isEvent: true }))\n        ];\n        // Sort with most recent first\n        return allItems.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));\n    }, [debugLogs, events]);\n\n    return h('div', { className: 'debug-console-overlay' },\n        h('div', { className: 'debug-console-header' },\n            h('span', null, 'DEBUG KONSOLE'),\n            h('button', {\n                className: 'close-button',\n                onClick: actions.toggleDebugConsole,\n                title: 'Konsole schließen',\n            }, '×')\n        ),\n        h('div', { className: 'debug-console-content' },\n            h('div', null,\n                combinedLogs.map(item => {\n                    if (item.isLog && item.type === 'ai-report') {\n                        return h('div', { key: item.id, className: 'debug-console-log ai-report' },\n                            h('pre', null, item.content)\n                        );\n                    }\n                    if (item.isEvent) {\n                         return h('p', { key: item.id, className: 'debug-console-log' },\n                            h('span', { className: 'timestamp' }, `[${new Date(item.timestamp).toLocaleTimeString()}]`),\n                            h('span', { dangerouslySetInnerHTML: { __html: item.message } })\n                        );\n                    }\n                    // Basic fallback for other log types\n                    return h('p', { key: item.id, className: 'debug-console-log' },\n                        h('span', { className: 'timestamp' }, `[${new Date(item.timestamp).toLocaleTimeString()}]`),\n                        typeof item.content === 'string' ? item.content : JSON.stringify(item.content)\n                    );\n                })\n            )\n        )\n    );\n};"
    },
    {
      "path": "src/components/ReportCard.js",
      "content": "\n\n\nimport { h } from 'preact';\n\nconst ReportCard = ({ report }) => {\n    const getFriendlyScreenName = (gameState) => {\n        const map = {\n            'game': 'Spielansicht', 'main-menu': 'Hauptmenü', 'settings': 'Optionen',\n            'profile-select': 'Profilauswahl', 'character-creator': 'Charaktererstellung',\n            'codex': 'Kodex', 'credits': 'Credits', 'system-check': 'Systemprüfung',\n            'report-viewer': 'Report-Ansicht', 'preload': 'Sitzungsauswahl',\n            'beta-key-entry': 'Beta-Schlüssel Eingabe', 'loading': 'Ladebildschirm',\n            'fix-verification': 'Fix-Verifizierung'\n        };\n        return map[gameState] || gameState;\n    };\n\n    const cardClasses = [\n        'report-card',\n        report.isArchived ? 'archived' : '',\n        report.reopened_from_failed_fix ? 'reopened' : ''\n    ].filter(Boolean).join(' ');\n\n    return h('div', { className: cardClasses },\n        h('div', { className: 'report-card-header' },\n            h('div', { className: 'report-card-title-wrapper' },\n                 h('h3', { className: 'report-card-title' }, report.category),\n                 report.isArchived && h('span', { className: 'report-archived-tag' }, 'Archiviert'),\n                 report.reopened_from_failed_fix && h('span', { className: 'report-archived-tag', style: { backgroundColor: 'var(--accent-negative)', color: 'white' } }, 'Wiedereröffnet')\n            ),\n            h('div', { className: 'report-card-meta' },\n                h('span', null, `Von: ${report.profileName}`),\n                h('span', null, `Am: ${new Date(report.timestamp).toLocaleString()}`),\n                h('span', null, `Screen: ${getFriendlyScreenName(report.gameStateAtReport)}`)\n            )\n        ),\n        h('p', { className: 'report-card-body' }, report.description)\n    );\n};\n\nexport { ReportCard };"
    },
    {
      "path": "src/components/FixVerificationView.js",
      "content": "\n\n\nimport { h } from 'preact';\nimport { useStore } from '../store/AppContext.js';\nimport { FixLogCard } from './FixLogCard.js';\n\nexport const FixVerificationView = () => {\n    const { fixLogs, actions, unverifiedFixLogsCount } = useStore();\n\n    const sortedLogs = [...fixLogs].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));\n\n    return h('div', { className: 'fix-verification-container' },\n        h('h1', { className: 'fix-verification-title' }, 'Fix-Verifizierung (QA)'),\n        h('div', { className: 'fix-verification-list' },\n            sortedLogs.length > 0 ? (\n                sortedLogs.map(log => h(FixLogCard, { key: log.id, fixLog: log }))\n            ) : (\n                h('p', { className: 'no-profiles-message' }, 'Keine Fix-Protokolle zum Verifizieren gefunden.')\n            )\n        ),\n        h('div', { className: 'fix-verification-footer' },\n             h('p', null, `${unverifiedFixLogsCount} Fix(es) benötigen eine Verifizierung.`),\n            h('div', { className: 'fix-verification-footer-actions'},\n                h('button', {\n                    className: 'button secondary',\n                    onClick: () => actions.setGameState('main-menu'),\n                }, 'Zurück zum Hauptmenü')\n            )\n        )\n    );\n};"
    },
    {
      "path": "src/components/FixLogCard.js",
      "content": "\n\n\nimport { h } from 'preact';\nimport { useStore } from '../store/AppContext.js';\n\nconst GRADING_SYSTEM = {\n    0: { label: 'Ausstehend', className: 'pending' },\n    1: { label: 'Sehr Gut', className: 'pass' },\n    2: { label: 'Gut', className: 'pass' },\n    3: { label: 'Befriedigend', className: 'pass' },\n    4: { label: 'Mangelhaft', className: 'fail' },\n    5: { label: 'Ungenügend', className: 'fail' },\n};\n\nexport const FixLogCard = ({ fixLog }) => {\n    const { actions } = useStore();\n\n    const currentGrade = fixLog.qaStatus?.grade || 0;\n    const statusInfo = GRADING_SYSTEM[currentGrade];\n\n    const getStatusTitle = () => {\n        if (currentGrade === 0) return 'QA Ausstehend';\n        if (currentGrade <= 3) return `QA Bestanden (Note: ${currentGrade})`;\n        return `QA Fehlgeschlagen (Note: ${currentGrade})`;\n    };\n\n    const cardClasses = [\n        'fix-log-card',\n        `qa-status-${statusInfo.className}`\n    ].filter(Boolean).join(' ');\n\n    return h('div', { className: cardClasses },\n        h('div', { className: 'fix-log-header' },\n            h('h3', { className: 'fix-log-title' }, getStatusTitle()),\n            h('span', { className: 'fix-log-timestamp' }, new Date(fixLog.timestamp).toLocaleString())\n        ),\n        h('div', { className: 'fix-log-body' },\n            h('p', null, h('strong', null, 'Analyse-Notiz: '), fixLog.aiFixNote),\n            h('p', { className: 'fix-log-linked-reports' }, \n                h('strong', null, `Bezieht sich auf ${fixLog.reportIds.length} Report(s): `),\n                fixLog.reportIds.join(', ')\n            )\n        ),\n        h('div', { className: 'fix-log-qa-form' },\n            h('span', { className: 'qa-grading-label' }, 'Bewertung abgeben:'),\n            h('div', { className: 'qa-grading-buttons' },\n                Object.entries(GRADING_SYSTEM)\n                    .filter(([grade]) => grade > 0) // Exclude \"Pending\" from buttons\n                    .map(([grade, info]) => h('button', {\n                        key: grade,\n                        className: `qa-grade-button grade-${grade} ${Number(grade) === currentGrade ? 'active' : ''}`,\n                        onClick: () => actions.updateFixLogQaStatus(fixLog.id, Number(grade)),\n                        title: info.label,\n                    }, grade))\n            )\n        )\n    );\n};"
    },
    {
      "path": "src/components/QuestTerminal.js",
      "content": "\n\n\nimport { h } from 'preact';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { useStore } from '../store/AppContext.js';\n\nconst bootSequence = [\n  { text: \"> Initializing Connection to AI Core...\", delay: 50, type: 'system' },\n  { text: \"> AI Core handshake successful. SYN/ACK received.\", delay: 300, type: 'system' },\n  { text: \"> I am the ScriptDaX narrative AI. Ready for operator input.\", delay: 200, type: 'system' },\n  { text: \"> Type 'help' or 'hilfe' for a list of commands.\", delay: 150, type: 'system' },\n];\n\nexport const QuestTerminal = () => {\n    const { quests, actions, characterStats, isLoading, isApiConfigured, activeProfile } = useStore();\n    const [output, setOutput] = useState([]);\n    const [command, setCommand] = useState('');\n    const [history, setHistory] = useState([]);\n    const [historyIndex, setHistoryIndex] = useState(-1);\n    const [currentQuest, setCurrentQuest] = useState(null);\n    const endOfOutputRef = useRef(null);\n    const inputRef = useRef(null);\n    \n    const runBootSequence = () => {\n        setOutput([]);\n        let currentDelay = 0;\n        bootSequence.forEach((line) => {\n            currentDelay += line.delay;\n            setTimeout(() => {\n                setOutput(prev => [...prev, line]);\n            }, currentDelay);\n        });\n    };\n\n    useEffect(() => {\n        runBootSequence();\n    }, []);\n\n    useEffect(() => {\n       if (endOfOutputRef.current) {\n            endOfOutputRef.current.scrollIntoView({ behavior: 'smooth' });\n       }\n    }, [output]);\n\n    useEffect(() => {\n        if (currentQuest && !quests.find(q => q.id === currentQuest.id)) {\n            setCurrentQuest(null);\n            addToOutput('> Aktuelle Quest nicht mehr verfügbar. Kehre zur Befehlszeile zurück.', 'system');\n        }\n    }, [quests, currentQuest]);\n\n    const addToOutput = (text, type = 'user') => {\n        setOutput(prev => [...prev, { type, text }]);\n    };\n    \n    const renderQuestList = () => {\n        let text = '> Verfügbare Quests:\\n';\n        if (quests.length === 0) {\n            text += '  [Keine aktiven Quests. Generieren Sie neue im Kontrollzentrum oder mit dem Befehl \"generate\".]';\n        } else {\n            quests.forEach((q, i) => {\n                const lockStatus = characterStats.level < q.minLevel ? ` [LOCKED - LVL ${q.minLevel}]` : '';\n                text += `  [${i + 1}] ${q.title}${lockStatus}\\n`;\n            });\n            text += '\\n> Geben Sie \"view <nr>\" oder \"ansehen <nr>\" ein, um Details anzuzeigen.';\n        }\n        addToOutput(text, 'system');\n    };\n    \n    const renderQuestDetails = (quest) => {\n        setCurrentQuest(quest);\n        let details = `> Lade Daten für Quest: \"${quest.title}\"...\\n\\n`;\n        details += `[NPC]: ${quest.npcName} (${quest.faction})\\n`;\n        details += `[ÜBERTRAGUNG]: \"${quest.dialogue}\"\\n\\n`;\n        details += `[Lagebericht]:\\n${quest.description}\\n\\n`;\n        details += `[Moralische Zwickmühle]:\\n${quest.moralChallenge}\\n\\n`;\n        details += `[Mögliche Ausgänge]:\\n`;\n        quest.outcomes.forEach((o, i) => {\n            const req = o.itemRequirement ? ` [BENÖTIGT: ${o.itemRequirement.itemName}]` : '';\n            details += `  [${i+1}] ${o.description}${req}\\n`;\n        });\n        details += `\\n> Geben Sie \"select <nr>\" oder \"auswählen <nr>\" ein, um eine Aktion auszuführen.`;\n        addToOutput(details, 'system');\n    };\n\n    const handleCommand = (cmd) => {\n        const [action, ...args] = cmd.toLowerCase().split(' ');\n        addToOutput(`${characterStats.displayName}> ${cmd}`, 'user');\n        \n        if (cmd.trim() !== '' && (history.length === 0 || history[history.length - 1] !== cmd)) {\n            setHistory(prev => [...prev, cmd]);\n        }\n        setHistoryIndex(-1);\n\n        switch (action) {\n            case 'hilfe':\n            case 'help':\n                addToOutput('> Verfügbare Befehle:\\n' +\n                    '  hilfe / help         - Zeigt diese Hilfe an\\n' +\n                    '  quests / list        - Listet alle verfügbaren Quests auf\\n' +\n                    '  view / ansehen <nr>  - Zeigt Details für eine Quest an\\n' +\n                    '  select / auswählen <nr> - Wählt einen Ausgang für die aktuelle Quest\\n' +\n                    '  generate / request   - Fordert neue Quests vom KI-Kern an\\n' +\n                    '  clear / leeren       - Löscht die Terminal-Anzeige', 'system');\n                break;\n            case 'quests':\n            case 'list':\n                setCurrentQuest(null);\n                renderQuestList();\n                break;\n            case 'view':\n            case 'ansehen':\n                const questIndex = parseInt(args[0], 10) - 1;\n                if (!isNaN(questIndex) && quests[questIndex]) {\n                    const quest = quests[questIndex];\n                    if (characterStats.level < quest.minLevel) {\n                        addToOutput(`> ZUGRIFF VERWEIGERT: Level ${quest.minLevel} erforderlich.`, 'error');\n                    } else {\n                        renderQuestDetails(quest);\n                    }\n                } else {\n                    addToOutput('> Fehler: Ungültige Quest-Nummer.', 'error');\n                }\n                break;\n            case 'select':\n            case 'auswählen':\n                 if (!currentQuest) {\n                    addToOutput('> Fehler: Keine Quest ausgewählt. Benutzen Sie \"view <nr>\".', 'error');\n                    break;\n                }\n                const outcomeIndex = parseInt(args[0], 10) - 1;\n                const chosenOutcome = currentQuest.outcomes[outcomeIndex];\n\n                if (!chosenOutcome) {\n                    addToOutput('> Fehler: Ungültige Ausgangs-Nummer.', 'error');\n                    break;\n                }\n\n                // Check for item requirement\n                const requirement = chosenOutcome.itemRequirement;\n                if (requirement) {\n                    const hasItem = (activeProfile.inventory || []).some(item => item.name === requirement.itemName);\n                    if (!hasItem) {\n                        addToOutput(`> ZUGRIFF VERWEIGERT: Benötigtes Item \"${requirement.itemName}\" nicht im Inventar.`, 'error');\n                        break;\n                    }\n                     addToOutput(`> Item \"${requirement.itemName}\" wird verwendet...`, 'warning');\n                }\n                \n                actions.resolveQuest(currentQuest.id, chosenOutcome);\n                addToOutput(`> Befehl ausgeführt: ${chosenOutcome.description}`, 'system');\n                setCurrentQuest(null);\n                break;\n            case 'generate':\n            case 'request':\n                if (isLoading) {\n                    addToOutput('> Fehler: Quest-Generierung läuft bereits.', 'warning');\n                } else if (!isApiConfigured) {\n                    addToOutput('> Fehler: API-Verbindung nicht konfiguriert. API_KEY fehlt.', 'error');\n                } else {\n                    addToOutput('> Fordere neue Quest-Daten vom KI-Kern an...', 'system');\n                    actions.generateNewQuests(activeProfile);\n                }\n                break;\n            case 'clear':\n            case 'leeren':\n                setCurrentQuest(null);\n                runBootSequence();\n                break;\n            default:\n                addToOutput(`> Fehler: Unbekannter Befehl \"${action}\".`, 'error');\n        }\n        setCommand('');\n    };\n    \n    const handleKeyDown = (e) => {\n        if (e.key === 'Enter') {\n            e.preventDefault();\n            handleCommand(command);\n        } else if (e.key === 'ArrowUp') {\n            e.preventDefault();\n            if (history.length > 0) {\n                const newIndex = historyIndex < 0 ? history.length - 1 : Math.max(0, historyIndex - 1);\n                setHistoryIndex(newIndex);\n                setCommand(history[newIndex]);\n            }\n        } else if (e.key === 'ArrowDown') {\n            e.preventDefault();\n             if (historyIndex >= 0 && historyIndex < history.length - 1) {\n                const newIndex = historyIndex + 1;\n                 setHistoryIndex(newIndex);\n                 setCommand(history[newIndex]);\n            } else {\n                setHistoryIndex(-1);\n                setCommand('');\n            }\n        }\n    };\n\n    return h('aside', { className: 'quest-terminal', onClick: () => inputRef.current?.focus() },\n        h('h1', { className: 'quest-terminal-header' }, 'Quest-Terminal'),\n        h('div', { className: 'quest-terminal-output' },\n            output.map((line, i) => h('div', { key: i, className: `terminal-line line-${line.type}` }, line.text)),\n            h('div', { ref: endOfOutputRef })\n        ),\n        h('div', { className: 'quest-terminal-input-container' },\n            h('span', { className: 'quest-terminal-prompt' }, `${characterStats.displayName}>`),\n            h('input', {\n                ref: inputRef,\n                className: 'quest-terminal-input',\n                type: 'text',\n                value: command,\n                onInput: (e) => setCommand(e.target.value),\n                onKeyDown: handleKeyDown,\n                spellcheck: false,\n                autofocus: true,\n            }),\n             h('span', { className: 'quest-terminal-caret' })\n        )\n    );\n};"
    },
    {
      "path": "src/services/aiAnalystService.js",
      "content": "\n// src/services/aiAnalystService.js\n\n// This service simulates an AI analyzing the current state and generating a report.\n// It does not make any actual API calls.\n\nconst gradeMetric = (value, thresholds) => {\n    if (value >= thresholds[0]) return 1; // Sehr Gut\n    if (value >= thresholds[1]) return 2; // Gut\n    if (value >= thresholds[2]) return 3; // Befriedigend\n    if (value >= thresholds[3]) return 4; // Ausreichend\n    return 5; // Mangelhaft\n};\n\nexport const aiAnalystService = {\n    generateReport: (state) => {\n        const {\n            profiles = [],\n            reports = [],\n            fixLogs = [],\n            activeProfile,\n        } = state;\n\n        // --- Data Points ---\n        const totalProfiles = profiles.length;\n        const totalQuests = profiles.reduce((sum, p) => sum + (p.quests?.length || 0), 0);\n        const totalCompletedQuests = profiles.reduce((sum, p) => sum + (p.completedQuests?.length || 0) + (p.failedQuests?.length || 0), 0);\n\n        const newReports = reports.filter(r => !r.isArchived).length;\n        const unverifiedFixes = fixLogs.filter(log => !log.qaStatus || log.qaStatus.grade === 0).length;\n        const failedFixes = fixLogs.filter(log => log.qaStatus && log.qaStatus.grade >= 4).length;\n\n        // --- Simulated Quality Metrics ---\n        const questCompletionRatio = totalCompletedQuests > 0 ? (profiles.reduce((sum, p) => sum + (p.completedQuests?.length || 0), 0) / totalCompletedQuests) * 100 : 100;\n        const qaSuccessRatio = fixLogs.length > 0 ? ((fixLogs.length - failedFixes) / fixLogs.length) * 100 : 100;\n        const codeQualityScore = (qaSuccessRatio + questCompletionRatio) / 2; // Simple simulation\n\n        // --- Grading ---\n        const gradeFuncUmfang = gradeMetric(totalQuests + totalCompletedQuests, [50, 25, 10, 5]);\n        const gradeUsability = gradeMetric(questCompletionRatio, [95, 85, 70, 60]);\n        const gradeFehleranfälligkeit = gradeMetric(100 - (failedFixes * 10), [95, 80, 60, 40]);\n        const gradeCodeQuality = gradeMetric(codeQualityScore, [95, 85, 75, 65]);\n        const overallGrade = (gradeFuncUmfang + gradeUsability + gradeFehleranfälligkeit + gradeCodeQuality) / 4;\n\n\n        // --- Report Generation ---\n        let report = `\n==============================================\n= KI-STATUSBERICHT - ${new Date().toLocaleString('de-DE')} =\n==============================================\n\nAnalyse basierend auf dem aktuellen Anwendungszustand.\n\n### 1. Kernmetriken & Datenpunkte\n\n- **Profile:** ${totalProfiles} Operator-Profile in der Datenbank.\n- **Aktiver Operator:** ${activeProfile?.characterStats?.displayName || 'Keiner'}\n- **Aktive Quests:** ${totalQuests} systemweit.\n- **Abgeschlossene Quests:** ${totalCompletedQuests} (insgesamt).\n- **Feedback-System:**\n    - Neue Reports: ${newReports}\n    - Unverifizierte Fixes: ${unverifiedFixes}\n    - Fehlgeschlagene Fixes (QA < 4): ${failedFixes}\n\n### 2. Qualitätsanalyse (Simuliert)\n\nAnalyse basierend auf Erfolgsquoten und Interaktionsdaten.\n\n- **Funktionsumfang (Note: ${gradeFuncUmfang})**\n  - Positiv: Stabiles Kern-Gameplay.\n  - Negativ: Mangel an sekundären Spielmechaniken (z.B. Inventar-Nutzung, Events).\n\n- **Usability (Note: ${gradeUsability})**\n  - Positiv: UI ist intuitiv; Quest-Abschlussrate ist hoch (${questCompletionRatio.toFixed(1)}%).\n  - Negativ: Interaktion ist primär textbasiert; könnte repetitiv werden.\n\n- **Fehleranfälligkeit (Note: ${gradeFehleranfälligkeit})**\n  - Positiv: State Management ist durch Reducer robust.\n  - Negativ: ${failedFixes > 0 ? `${failedFixes} Fix(es) wurde(n) als mangelhaft bewertet. Dies deutet auf wiederkehrende Probleme hin.` : 'Aktuell keine als mangelhaft bewerteten Fixes.'}\n\n- **Code-Qualität (Note: ${gradeCodeQuality.toFixed(1)})**\n  - Positiv: Gute Modularisierung durch Komponenten und State-Reducer.\n  - Negativ: Testabdeckung ist weiterhin eine Schwachstelle und sollte ausgebaut werden.\n\n### 3. Externe Marktanalyse (Zusammenfassung)\n\n- **KI-Code-Assistenten:** Höchste Priorität zur Steigerung der Entwickler-Effizienz und Code-Qualität.\n- **KI-Agenten-Plattformen:** Wichtig für die Konzeption zukünftiger Architekturen und autonomer Features innerhalb des OS.\n- **Kreativ- & Multimedia-KIs:** Strategisches Potenzial zur Anreicherung von Spielinhalten (z.B. prozedurale Narrative).\n\n### 4. Handlungsempfehlungen (Prioritäten)\n\n1.  **Stabilität sichern:** Verifizieren Sie die ${unverifiedFixes} ausstehenden Fixes im QA-Panel. Analysieren Sie die ${failedFixes} fehlgeschlagenen Fixes, um Problemursachen zu finden.\n2.  **Strategische Weiterentwicklung:** Prüfen Sie die Teilnahme an \"Code Assistant\"-Betaprogrammen, um die Code-Qualität langfristig zu steigern (siehe Marktanalyse).\n3.  **Testabdeckung erhöhen:** Schreiben Sie weitere Unit-Tests für Kern-Services und Reducer-Logik.\n\n==============================================\n= ENDE DER ÜBERTRAGUNG                     =\n==============================================\n`;\n        return report.trim();\n    }"
    },
    {
      "path": "src/store/reducer.test.js",
      "content": "\n\n\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { appReducer, initialState } from './reducer.js';\nimport * as initial from './initialState.js';\nimport { origins } from '../config/origins.js';\n\n// --- MOCK DATA ---\nconst getMockState = () => {\n    // This function provides a clean, \"source of truth\" state object.\n    // It doesn't pre-run the reducer, ensuring tests are isolated and predictable.\n    // It only contains the raw data that would be loaded from storage.\n    const rawState = JSON.parse(JSON.stringify({\n        ...initialState,\n        rawProfiles: [{\n            id: 'p1',\n            characterStats: {\n                name: 'Tester',\n                level: 1,\n                xp: 0,\n                credits: 1000,\n                morality: 50,\n                reputation: { \"Stellar Federation\": 50, \"Mars Conglomerate\": 50 },\n            },\n            quests: [{ id: 'q1', title: 'Test Quest' }],\n            completedQuests: [{ id: 'qc1' }], \n            failedQuests: [{ id: 'qf1' }], \n            inventory: [],\n        }],\n        activeProfileId: 'p1',\n    }));\n    // We run one LOAD action to correctly derive state like `activeProfile`, `quests` etc.\n    // This simulates the app's state after a profile has been loaded.\n    return appReducer(rawState, { type: 'LOAD_PROFILE', payload: 'p1' });\n};\n\n\ndescribe('appReducer', () => {\n\n    beforeEach(() => {\n        vi.clearAllMocks();\n    });\n\n    describe('RESOLVE_QUEST', () => {\n        const mockQuest = { id: 'q1', title: 'Test Quest' };\n        \n        it('sollte bei erfolgreichem Ausgang Belohnungen korrekt anwenden', () => {\n            const chosenOutcome = {\n                status: 'success',\n                rewards: { xp: 50, credits: 100, morality: 10, reputation: { faction: 'Stellar Federation', change: 5 } },\n            };\n            const action = { type: 'RESOLVE_QUEST', payload: { quest: mockQuest, chosenOutcome } };\n            const newState = appReducer(getMockState(), action);\n            const p = newState.activeProfile;\n            \n            expect(p.characterStats.xp).toBe(50);\n            expect(p.characterStats.credits).toBe(1100);\n            expect(p.characterStats.morality).toBe(60);\n            expect(p.characterStats.reputation['Stellar Federation']).toBe(55);\n            expect(p.quests).toHaveLength(0);\n            expect(p.completedQuests).toHaveLength(2);\n            expect(p.completedQuests[1].id).toBe('q1');\n            expect(p.failedQuests).toHaveLength(1);\n        });\n\n        it('sollte bei Fehlschlag Strafen korrekt anwenden', () => {\n            const chosenOutcome = {\n                status: 'failure',\n                rewards: { xp: 10, credits: -50, morality: -15, reputation: { faction: 'Mars Conglomerate', change: -10 } },\n            };\n            const action = { type: 'RESOLVE_QUEST', payload: { quest: mockQuest, chosenOutcome } };\n            const newState = appReducer(getMockState(), action);\n            const p = newState.activeProfile;\n\n            expect(p.characterStats.xp).toBe(10);\n            expect(p.characterStats.credits).toBe(950);\n            expect(p.characterStats.morality).toBe(35);\n            expect(p.characterStats.reputation['Mars Conglomerate']).toBe(40);\n            expect(p.quests).toHaveLength(0);\n            expect(p.completedQuests).toHaveLength(1);\n            expect(p.failedQuests).toHaveLength(2);\n        });\n\n        it('sollte einen Levelaufstieg korrekt handhaben', () => {\n            const xpForLevelUp = initial.XP_FOR_NEXT_LEVEL(1);\n            const chosenOutcome = {\n                status: 'success',\n                rewards: { xp: xpForLevelUp + 20, credits: 0, morality: 0, reputation: { faction: 'Stellar Federation', change: 0 } }\n            };\n            const action = { type: 'RESOLVE_QUEST', payload: { quest: mockQuest, chosenOutcome } };\n            const newState = appReducer(getMockState(), action);\n            const p = newState.activeProfile;\n\n            expect(p.characterStats.level).toBe(2);\n            expect(p.characterStats.xp).toBe(20);\n        });\n        \n        it('sollte ein Item zum Inventar hinzufügen', () => {\n            const newItem = { id: 'item1', name: 'Data Chip', description: 'A chip.', icon: 'chip' };\n            const chosenOutcome = {\n                status: 'success',\n                rewards: { xp: 50, credits: 100, morality: 0, reputation: { faction: 'Stellar Federation', change: 5 }, item: newItem },\n            };\n            const action = { type: 'RESOLVE_QUEST', payload: { quest: mockQuest, chosenOutcome } };\n            const newState = appReducer(getMockState(), action);\n            const p = newState.activeProfile;\n\n            expect(p.inventory).toHaveLength(1);\n            expect(p.inventory[0]).toEqual(newItem);\n        });\n    });\n\n    describe('Profile Management', () => {\n        it('CREATE_PROFILE: sollte ein neues Profil mit korrekten Startwerten erstellen', () => {\n            const creationData = {\n                id: 'p2',\n                name: 'Newbie',\n                origin: origins.find(o => o.id === 'mars_heir'),\n                learningGoal: { keyword: 'testing', description: 'learn it' },\n            };\n            const action = { type: 'CREATE_PROFILE', payload: creationData };\n            const newState = appReducer(getMockState(), action);\n            \n            expect(newState.rawProfiles).toHaveLength(2);\n            expect(newState.activeProfileId).toBe('p2');\n            const p = newState.activeProfile;\n            expect(p.characterStats.name).toBe('Newbie');\n            expect(p.characterStats.credits).toBe(1000 + 500); // default + modifier\n            expect(p.characterStats.morality).toBe(50 - 10);\n            expect(p.characterStats.reputation['Mars Conglomerate']).toBe(50 + 15);\n        });\n        \n        it('DELETE_PROFILE: sollte ein inaktives Profil löschen', () => {\n            let state = getMockState();\n            state.rawProfiles.push({ id: 'p2', characterStats: { name: 'ToDelete' } });\n            state = appReducer(state, { type: 'LOAD_PROFILE', payload: 'p1' }); // Re-derive profiles\n            \n            const action = { type: 'DELETE_PROFILE', payload: 'p2' };\n            const newState = appReducer(state, action);\n            \n            expect(newState.rawProfiles.find(p => p.id === 'p2')).toBeUndefined();\n            expect(newState.activeProfileId).toBe('p1');\n        });\n\n        it('DELETE_ACTIVE_PROFILE: sollte das aktive Profil löschen und die Session zurücksetzen', () => {\n            const action = { type: 'DELETE_ACTIVE_PROFILE' };\n            const newState = appReducer(getMockState(), action);\n\n            expect(newState.rawProfiles).toHaveLength(0);\n            expect(newState.activeProfileId).toBeNull();\n            expect(newState.activeProfile).toBeNull();\n            expect(newState.gameState).toBe('main-menu');\n        });\n\n        it('IMPORT_PROFILES: sollte neue Profile hinzufügen und bestehende aktualisieren', () => {\n            const profilesToImport = [\n                { id: 'p1', characterStats: { name: 'Tester', credits: 9999 } }, // Update\n                { id: 'p3', characterStats: { name: 'Newcomer' } }, // Add\n            ];\n            const action = { type: 'IMPORT_PROFILES', payload: profilesToImport };\n            const newState = appReducer(getMockState(), action);\n            \n            expect(newState.rawProfiles).toHaveLength(2);\n            expect(newState.rawProfiles.find(p => p.id === 'p1').characterStats.credits).toBe(9999);\n            expect(newState.rawProfiles.find(p => p.id === 'p3')).toBeDefined();\n        });\n    });\n\n    describe('Quest Generation', () => {\n        it('GENERATE_QUESTS_SUCCESS: sollte Quests und neue NPCs zum aktiven Profil hinzufügen', () => {\n            const state = getMockState();\n            state.rawProfiles[0].discoveredNPCs = [{ name: 'NPC-A', faction: 'F1' }];\n\n            const newQuests = [\n                { id: 'q2', npcName: 'NPC-A', faction: 'F1' },\n                { id: 'q3', npcName: 'NPC-B', faction: 'F2' },\n            ];\n            \n            const action = { type: 'GENERATE_QUESTS_SUCCESS', payload: { quests: newQuests, profileId: 'p1' } };\n            const newState = appReducer(state, action);\n            const p = newState.activeProfile;\n\n            expect(p.quests).toHaveLength(3); // 1 initial + 2 new\n            expect(p.discoveredNPCs).toHaveLength(2); // Should not add duplicates\n            expect(p.discoveredNPCs.find(n => n.name === 'NPC-B')).toBeDefined();\n        });\n    });\n    \n    describe('Debug Actions', () => {\n        it('ADD_DEBUG_CREDITS: sollte 5000 Credits hinzufügen', () => {\n            const action = { type: 'ADD_DEBUG_CREDITS' };\n            const newState = appReducer(getMockState(), action);\n            expect(newState.activeProfile.characterStats.credits).toBe(6000);\n        });\n\n        it('ADD_DEBUG_XP: sollte 250 XP hinzufügen und einen Levelaufstieg auslösen', () => {\n            const action = { type: 'ADD_DEBUG_XP' };\n            const newState = appReducer(getMockState(), action);\n            // 250 XP on Level 1 (needs 100) -> Level 2 with 150 XP\n            expect(newState.activeProfile.characterStats.level).toBe(2);\n            expect(newState.activeProfile.characterStats.xp).toBe(150);\n        });\n\n        it('RESET_QUESTS: sollte alle Quest-Listen leeren', () => {\n             const action = { type: 'RESET_QUESTS' };\n             const newState = appReducer(getMockState(), action);\n             const p = newState.activeProfile;\n\n             expect(p.quests).toHaveLength(0);\n             expect(p.completedQuests).toHaveLength(0);\n             expect(p.failedQuests).toHaveLength(0);\n        });\n    });\n});"
    },
    {
      "path": "src/components/settings/Slider.js",
      "content": "\n\n\nimport { h } from 'preact';\n\nexport const Slider = ({ label, value, onInput }) => {\n    return h('div', { className: 'setting-item' },\n        h('label', { htmlFor: `slider-${label}` }, label),\n        h('div', { className: 'slider-container' },\n            h('input', {\n                type: 'range',\n                id: `slider-${label}`,\n                min: 0,\n                max: 100,\n                value,\n                onInput\n            }),\n            h('span', { className: 'slider-value' }, value)\n        )\n    );\n};"
    },
    {
      "path": "src/components/settings/DeleteActiveProfileButton.js",
      "content": "\n\n\nimport { h } from 'preact';\nimport { useState, useEffect } from 'preact/hooks';\nimport { useStore } from '../../store/AppContext.js';\n\nexport const DeleteActiveProfileButton = () => {\n    const { activeProfile, actions } = useStore();\n    const [confirmState, setConfirmState] = useState('idle'); // 'idle', 'confirming'\n    const [countdown, setCountdown] = useState(5);\n\n    useEffect(() => {\n        let timer;\n        if (confirmState === 'confirming' && countdown > 0) {\n            timer = setTimeout(() => setCountdown(c => c - 1), 1000);\n        } else if (confirmState === 'confirming' && countdown === 0) {\n            setConfirmState('idle'); // Reset if time runs out\n        }\n        return () => clearTimeout(timer);\n    }, [confirmState, countdown]);\n\n    const handleInitialClick = () => {\n        if (window.confirm(`Möchten Sie das Profil '${activeProfile.characterStats.displayName}' wirklich unwiderruflich löschen?`)) {\n            setConfirmState('confirming');\n            setCountdown(5);\n        }\n    };\n    \n    const handleConfirmClick = () => {\n        actions.deleteActiveProfile();\n        setConfirmState('idle');\n    };\n\n    if (confirmState === 'confirming') {\n        return h('button', {\n            className: 'button danger',\n            onClick: handleConfirmClick,\n        }, `Bestätigen (${countdown}s)`);\n    }\n\n    return h('button', {\n        className: 'button secondary danger',\n        onClick: handleInitialClick,\n        disabled: !activeProfile,\n    }, 'Aktives Profil löschen');\n};"
    },
    {
      "path": "src/components/settings/OperatorData.js",
      "content": "\nimport { h } from 'preact';\nimport { useStore } from '../../store/AppContext.js';\nimport { DeleteActiveProfileButton } from './DeleteActiveProfileButton.js';\n\nexport const OperatorData = () => {\n    const { actions, activeProfile, profiles } = useStore();\n    \n    const handleImportClick = () => {\n        const input = document.createElement('input');\n        input.type = 'file';\n        input.accept = '.json,.zip,application/json,application/zip';\n        input.style.display = 'none';\n        input.onchange = (e) => {\n            actions.importData(e);\n            document.body.removeChild(input);\n        };\n        document.body.appendChild(input);\n        input.click();\n    };\n\n    const handleRestoreClick = () => {\n        if (!window.confirm('WARNUNG: Dies wird den gesamten aktuellen Anwendungszustand (alle Profile, Einstellungen etc.) unwiderruflich mit den Daten aus der Backup-Datei überschreiben. Fortfahren?')) {\n            return;\n        }\n        const input = document.createElement('input');\n        input.type = 'file';\n        input.accept = '.json,application/json';\n        input.style.display = 'none';\n        input.onchange = (e) => {\n            actions.restoreFromBackup(e);\n            document.body.removeChild(input);\n        };\n        document.body.appendChild(input);\n        input.click();\n    };\n\n    return h('div', null,\n        h('h2', { className: 'setting-section-title' }, 'Operator-Daten'),\n        h('div', { className: 'setting-item' },\n            h('label', null, 'Profil exportieren'),\n            h('div', { className: 'setting-item-actions' },\n                h('button', {\n                    className: 'button secondary',\n                    onClick: actions.exportProfileZip,\n                    disabled: !activeProfile,\n                }, 'Aktives Profil (.zip)'),\n                 h('button', {\n                    className: 'button secondary',\n                    onClick: actions.exportAllProfilesZip,\n                    disabled: profiles.length === 0,\n                }, 'Alle Profile (.zip)')\n            )\n        ),\n        h('div', { className: 'setting-item' },\n             h('label', { for: 'import-data-input' }, 'Daten importieren'),\n            h('div', { className: 'setting-item-actions' },\n                h('button', { \n                    className: 'button secondary',\n                    onClick: handleImportClick,\n                }, 'Daten importieren')\n            )\n        ),\n        h('div', { className: 'setting-item' },\n            h('label', null, 'Aktives Profil löschen'),\n            h('div', { className: 'setting-item-actions' },\n                h(DeleteActiveProfileButton)\n            )\n        ),\n\n        h('h2', { className: 'setting-section-title' }, 'System-Backup & Wiederherstellung'),\n         h('p', { style: { color: 'var(--text-meta)', fontSize: '0.9rem', marginTop: '-0.75rem', marginBottom: '1rem' } },\n            'Sichern Sie den gesamten Anwendungszustand, um Datenverlust durch Browser-Fehler vorzubeugen.'\n        ),\n        h('div', { className: 'setting-item' },\n            h('label', null, 'Vollständiges Backup'),\n            h('div', { className: 'setting-item-actions' },\n                h('button', {\n                    className: 'button secondary',\n                    onClick: actions.createBackup,\n                }, 'Backup erstellen (.json)')\n            )\n        ),\n        h('div', { className: 'setting-item' },\n            h('label', null, 'Aus Backup wiederherstellen'),\n            h('div', { className: 'setting-item-actions' },\n                h('button', { \n                    className: 'button secondary danger',\n                    onClick: handleRestoreClick,\n                }, 'Backup laden...')\n            )\n        )\n    );\n};"
    },
    {
      "path": "src/components/character_creator/useTypingEffect.js",
      "content": "\n\n\nimport { useState, useEffect } from 'preact/hooks';\n\nexport const useTypingEffect = (text, speed = 10) => {\n    const [displayedText, setDisplayedText] = useState('');\n\n    useEffect(() => {\n        setDisplayedText(''); // Reset on new text\n        if (text) {\n            let i = 0;\n            const timer = setInterval(() => {\n                if (i < text.length) {\n                    setDisplayedText(prev => prev + text.charAt(i));\n                    i++;\n                } else {\n                    clearInterval(timer);\n                }\n            }, speed);\n            return () => clearInterval(timer);\n        }\n    }, [text, speed]);\n\n    return displayedText;\n};"
    },
    {
      "path": "src/components/character_creator/Modifier.js",
      "content": "\n\n\nimport { h } from 'preact';\nimport { Icon } from '../Icon.js';\n\nexport const Modifier = ({ label, value, icon }) => {\n    if (value === 0) return null;\n    const sign = value > 0 ? '+' : '';\n    const className = value > 0 ? 'positive' : 'negative';\n    return h('li', { className }, h(Icon, { name: icon, size: 14 }), ` ${sign}${value} ${label}`);\n};"
    },
    {
      "path": "src/components/character_creator/OriginDisplay.js",
      "content": "\n\n\nimport { h } from 'preact';\nimport { useTypingEffect } from './useTypingEffect.js';\nimport { Modifier } from './Modifier.js';\n\nexport const OriginDisplay = ({ origin }) => {\n    const typedDescription = useTypingEffect(origin.description);\n    \n    if (!origin) return h('div', { className: 'origin-display-panel' }, '> Wähle eine Herkunft aus der Liste, um Details anzuzeigen...');\n\n    return h('div', { className: 'origin-display-panel' },\n        h('h3', null, `> ${origin.name}`),\n        h('p', null, typedDescription),\n        h('ul', { className: 'modifiers-list' },\n            h(Modifier, { label: 'Credits', value: origin.modifiers.credits, icon: 'credits' }),\n            h(Modifier, { label: 'Moral', value: origin.modifiers.morality, icon: 'morality' }),\n            ...Object.entries(origin.modifiers.reputation).map(([faction, value]) =>\n                h(Modifier, { key: faction, label: faction, value, icon: 'reputation' })\n            )\n        )\n    );\n};"
    },
    {
      "path": "src/components/ItemTooltip.js",
      "content": "\n\n\nimport { h } from 'preact';\nimport { Icon } from './Icon.js';\n\nexport const ItemTooltip = ({ item, position }) => {\n    if (!item) return null;\n\n    // Position the tooltip. Add a small offset to avoid covering the cursor.\n    const style = {\n        left: `${position.x + 15}px`,\n        top: `${position.y + 15}px`,\n    };\n\n    return h('div', { className: 'item-tooltip', style: style },\n        h('div', { className: 'item-tooltip-header' },\n            h(Icon, { name: item.icon || 'inventory', size: 24 }),\n            h('h3', { className: 'item-tooltip-name' }, item.name)\n        ),\n        h('p', { className: 'item-tooltip-description' }, item.description)\n    );\n};"
    },
    {
      "path": "src/services/aiService.test.js",
      "content": "\n\n\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { aiService } from './aiService.js';\nimport { fallbackQuests } from '../config/fallbackQuests.js';\n\n// Mock the global fetch function\nglobal.fetch = vi.fn();\n\ndescribe('aiService', () => {\n    beforeEach(() => {\n        fetch.mockClear();\n    });\n\n    it('isConfigured should always be true', () => {\n        expect(aiService.isConfigured).toBe(true);\n    });\n\n    it('generateQuests should call the proxy endpoint with the correct payload', async () => {\n        const mockApiResponse = { quests: [], usage: { totalTokens: 120 } };\n        fetch.mockResolvedValue({\n            ok: true,\n            json: () => Promise.resolve(mockApiResponse),\n        });\n\n        const mockProfile = { id: 'p1', characterStats: { name: 'Test Operator' } };\n        const mockSettings = { useLocalFallback: false };\n        const mockMindsetState = 'neutral';\n        const mockHistory = ['Old Quest'];\n\n        await aiService.generateQuests(mockProfile, mockSettings, mockMindsetState, mockHistory);\n\n        expect(fetch).toHaveBeenCalledOnce();\n        const [url, options] = fetch.mock.calls[0];\n        \n        expect(url).toBe('/api/gemini-proxy');\n        expect(options.method).toBe('POST');\n        const body = JSON.parse(options.body);\n        expect(body.service).toBe('generateQuests');\n        expect(body.payload).toEqual({\n            characterProfile: mockProfile,\n            mindsetState: mockMindsetState,\n            completedQuestHistory: mockHistory,\n        });\n    });\n\n    it('generateQuests should return data directly from the proxy', async () => {\n        const mockApiResponse = { quests: [{ title: 'Proxy Quest' }], usage: { totalTokens: 150, source: 'api' } };\n        fetch.mockResolvedValue({\n            ok: true,\n            json: () => Promise.resolve(mockApiResponse),\n        });\n\n        const result = await aiService.generateQuests({}, { useLocalFallback: false });\n\n        expect(result).toEqual(mockApiResponse);\n    });\n    \n    it('should use local fallback quests when useLocalFallback setting is true', async () => {\n        const result = await aiService.generateQuests({}, { useLocalFallback: true });\n\n        expect(fetch).not.toHaveBeenCalled();\n        expect(result.quests).toEqual(fallbackQuests);\n        expect(result.usage.source).toBe('local');\n    });\n\n    it('should throw a detailed error if the proxy fetch is not ok', async () => {\n        fetch.mockResolvedValue({\n            ok: false,\n            status: 500,\n            statusText: \"Internal Server Error\",\n            text: () => Promise.resolve(\"Proxy function failed\"),\n        });\n        \n        await expect(aiService.generateQuests({}, { useLocalFallback: false }))\n            .rejects\n            .toThrow('API Proxy Error: 500 Internal Server Error - Proxy function failed');\n    });\n\n    it('getAIBetaProgramOpinion should call the proxy and return the text', async () => {\n        const mockApiResponse = { text: \"This is an opinion.\" };\n         fetch.mockResolvedValue({\n            ok: true,\n            json: () => Promise.resolve(mockApiResponse),\n        });\n\n        const result = await aiService.getAIBetaProgramOpinion();\n        expect(fetch).toHaveBeenCalledWith('/api/gemini-proxy', expect.any(Object));\n        const body = JSON.parse(fetch.mock.calls[0][1].body);\n        expect(body.service).toBe('getAIBetaProgramOpinion');\n        expect(result).toBe(\"This is an opinion.\");\n    });\n});"
    },
    {
      "path": "src/components/ProfileSelector.test.js",
      "content": "\n\n\nimport { h } from 'preact';\nimport { render, screen, fireEvent } from '@testing-library/preact';\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { ProfileSelector } from './ProfileSelector.js';\nimport { AppContext } from '../store/AppContext.js';\n\n// Mock JSZip at the top level to prevent resolution issues.\nvi.mock('jszip', () => ({\n    default: vi.fn()\n}));\n\nconst mockActions = {\n    loadProfile: vi.fn(),\n    deleteProfile: vi.fn(),\n    setGameState: vi.fn(),\n};\n\nconst mockProfiles = [\n    {\n        id: '1',\n        lastPlayed: new Date().toISOString(),\n        characterStats: { displayName: 'John Doe' },\n        isDeveloper: false,\n        isBetaTester: true,\n    },\n    {\n        id: '2',\n        lastPlayed: new Date(0).toISOString(),\n        characterStats: { displayName: 'Jane Smith' },\n        isDeveloper: true,\n        isBetaTester: false,\n    }\n];\n\nconst renderWithContext = (profiles = mockProfiles) => {\n    const mockStore = {\n        profiles: profiles,\n        actions: mockActions,\n    };\n    return render(\n        h(AppContext.Provider, { value: mockStore },\n            h(ProfileSelector)\n        )\n    );\n};\n\ndescribe('ProfileSelector', () => {\n    beforeEach(() => {\n        vi.clearAllMocks();\n        // Mock window.confirm for the delete button tests\n        window.confirm = vi.fn(() => true);\n    });\n\n    it('should render the list of profiles sorted by lastPlayed date', () => {\n        renderWithContext();\n        \n        const profileNames = screen.getAllByRole('heading', { level: 3 });\n        // John Doe played more recently, so he should appear first.\n        expect(profileNames[0].textContent).toBe('John Doe');\n        expect(profileNames[1].textContent).toBe('Jane Smith');\n    });\n\n    it('should show a message if no profiles exist', () => {\n        renderWithContext([]);\n        expect(screen.getByText('Keine gespeicherten Profile gefunden. Starten Sie ein neues Spiel.')).toBeDefined();\n    });\n\n    it('should call loadProfile when a profile card is clicked', () => {\n        renderWithContext();\n        // The entire card is clickable\n        fireEvent.click(screen.getByText('John Doe'));\n        expect(mockActions.loadProfile).toHaveBeenCalledWith('1');\n    });\n\n    it('should call deleteProfile after confirmation', async () => {\n        renderWithContext();\n        const deleteButtons = screen.getAllByRole('button', { name: 'Löschen' });\n        \n        // First click triggers the confirmation\n        fireEvent.click(deleteButtons[0]);\n        expect(window.confirm).toHaveBeenCalled();\n\n        // The button text changes to 'Bestätigen (5s)' after the first click\n        const confirmButton = await screen.findByText(/Bestätigen/);\n        fireEvent.click(confirmButton);\n        \n        expect(mockActions.deleteProfile).toHaveBeenCalledWith('1');\n    });\n\n    it('should call setGameState to go back to the main menu', () => {\n        renderWithContext();\n        const backButton = screen.getByRole('button', { name: 'Zurück zum Menü' });\n        fireEvent.click(backButton);\n        expect(mockActions.setGameState).toHaveBeenCalledWith('main-menu');\n    });\n});"
    },
    {
      "path": "src/config/fallbackQuests.js",
      "content": "\n// src/config/fallbackQuests.js\n// This file provides a static set of quests for development and testing.\n// It's used when the \"Sparmodus\" (local fallback) is enabled to avoid API costs.\n\nexport const fallbackQuests = [\n  {\n    \"id\": \"fallback-001\",\n    \"title\": \"Lokale Daten-Anomalie\",\n    \"description\": \"Ein seltsames Signal stört die lokalen Subraum-Kommunikationsrelais. Wir müssen die Quelle finden, bevor das gesamte System ausfällt. Die Daten deuten auf einen alten Server-Knoten im Alpha-Sektor hin.\",\n    \"moralChallenge\": \"Die Daten könnten wertvoll oder gefährlich sein. Bergen Sie sie zur Analyse oder löschen Sie sie, um jedes Risiko zu vermeiden?\",\n    \"faction\": \"Stellar Federation\",\n    \"requirements\": \"Keine besonderen Anforderungen.\",\n    \"minLevel\": 1,\n    \"sector\": \"alpha\",\n    \"npcName\": \"Sys-Admin Eva\",\n    \"dialogue\": \"Operator, wir haben ein Problem. Ein Geist in der Maschine. Finden Sie ihn.\",\n    \"outcomes\": [\n      {\n        \"description\": \"Server-Knoten sicher herunterfahren und Daten zur Analyse an die Föderation übergeben.\",\n        \"status\": \"success\",\n        \"rewards\": {\n          \"xp\": 50,\n          \"credits\": 100,\n          \"morality\": 5,\n          \"reputation\": { \"faction\": \"Stellar Federation\", \"change\": 10 }\n        }\n      },\n      {\n        \"description\": \"Den Server-Knoten mit einem EMP-Impuls aus der Ferne zerstören, um die Anomalie schnell zu beseitigen.\",\n        \"status\": \"success\",\n        \"rewards\": {\n          \"xp\": 30,\n          \"credits\": 50,\n          \"morality\": -10,\n          \"reputation\": { \"faction\": \"Stellar Federation\", \"change\": -5 }\n        }\n      }\n    ]\n  },\n  {\n    \"id\": \"fallback-002\",\n    \"title\": \"Der Preis des Fortschritts\",\n    \"description\": \"Ein Wissenschaftler des Jupiter-Kollektivs hat einen neuen KI-Algorithmus entwickelt, der das Potenzial hat, die Energieeffizienz um 300% zu steigern. Das Mars-Konglomerat will die Technologie um jeden Preis.\",\n    \"moralChallenge\": \"Schützen Sie das geistige Eigentum des Kollektivs oder verkaufen Sie es an den Meistbietenden für einen schnellen Profit?\",\n    \"faction\": \"Jupiter Collective\",\n    \"requirements\": \"Ein grundlegendes Verständnis von Unternehmensethik.\",\n    \"minLevel\": 2,\n    \"sector\": \"gamma\",\n    \"npcName\": \"Dr. Aris Thorne\",\n    \"dialogue\": \"Meine Forschung ist nicht zu verkaufen! Aber das Konglomerat hört einfach nicht zu. Helfen Sie mir!\",\n    \"outcomes\": [\n      {\n        \"description\": \"Die Forschungsdaten an das Kollektiv zurückgeben und ihre sichere Übertragung gewährleisten.\",\n        \"status\": \"success\",\n        \"rewards\": {\n          \"xp\": 75,\n          \"credits\": 200,\n          \"morality\": 15,\n          \"reputation\": { \"faction\": \"Jupiter Collective\", \"change\": 15 },\n          \"item\": {\n            \"id\": \"item-fallback-01\",\n            \"name\": \"Effizienz-Algorithmus\",\n            \"description\": \"Ein Daten-Chip, der einen revolutionären Energieeffizienz-Algorithmus enthält.\",\n            \"type\": \"Data-Chip\",\n            \"icon\": \"chip\"\n          }\n        }\n      },\n      {\n        \"description\": \"Die Daten heimlich an einen Agenten des Mars-Konglomerats verkaufen.\",\n        \"status\": \"success\",\n        \"rewards\": {\n          \"xp\": 40,\n          \"credits\": 1500,\n          \"morality\": -15,\n          \"reputation\": { \"faction\": \"Jupiter Collective\", \"change\": -20 }\n        }\n      }\n    ]\n  },\n  {\n    \"id\": \"fallback-003\",\n    \"title\": \"Unternehmens-Sabotage\",\n    \"description\": \"Ein Frachter des Mars-Konglomerats, der illegale Cyberwaffen transportiert, ist im Beta-Sektor gestrandet. Dies ist eine Gelegenheit, ihre Operationen zu stören.\",\n    \"moralChallenge\": \"Melden Sie den Frachter den Behörden der Föderation oder nutzen Sie die Gelegenheit, um die Waffen für sich selbst zu 'bergen'?\",\n    \"faction\": \"Mars Conglomerate\",\n    \"minLevel\": 1,\n    \"sector\": \"beta\",\n    \"npcName\": \"Anonymer Tippgeber\",\n    \"dialogue\": \"Wenn Sie schnell sind, können Sie dem Konglomerat einen empfindlichen Schlag versetzen. Der Frachter 'Fortune's Folly' ist ungeschützt.\",\n    \"outcomes\": [\n      {\n        \"description\": \"Die Koordinaten des Frachters an die Sicherheit der Föderation weiterleiten.\",\n        \"status\": \"success\",\n        \"rewards\": {\n          \"xp\": 60,\n          \"credits\": 150,\n          \"morality\": 10,\n          \"reputation\": { \"faction\": \"Mars Conglomerate\", \"change\": -10 }\n        }\n      },\n      {\n        \"description\": \"Die Waffenkisten aus dem Frachter stehlen, bevor jemand etwas bemerkt.\",\n        \"status\": \"failure\",\n        \"rewards\": {\n          \"xp\": 20,\n          \"credits\": -100,\n          \"morality\": -10,\n          \"reputation\": { \"faction\": \"Mars Conglomerate\", \"change\": 5 }\n        }\n      }\n    ]\n  }\n];"
    },
    {
      "path": "src/services/persistenceService.js",
      "content": "\n// src/services/persistenceService.js\n\n/**\n * Abstraction layer for data persistence.\n * This service now handles the entire application state as a single, consolidated object,\n * which is more robust and efficient than managing multiple individual localStorage keys.\n */\nconst APP_STATE_KEY = 'scriptdax_os_full_state';\n\nexport const persistenceService = {\n    /**\n     * Loads the entire application state from localStorage.\n     * @param {object} defaultState - The default state to return if nothing is found.\n     * @returns {object} The loaded state or the default state.\n     */\n    loadFullState: (defaultState) => {\n        try {\n            const item = localStorage.getItem(APP_STATE_KEY);\n            // Merge the loaded state with the default state to ensure new properties are included\n            return item ? { ...defaultState, ...JSON.parse(item) } : defaultState;\n        } catch (error) {\n            console.error(`[Persistence] Error reading state from localStorage. Returning default state.`, error);\n            return defaultState;\n        }\n    },\n\n    /**\n     * Saves the entire application state to localStorage.\n     